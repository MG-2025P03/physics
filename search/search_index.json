{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction This is the website for Meynard Gilhang's Physics activities. This is my first time to use GitHub and i'm still grasping for the new web technologies and I'm trying to adapt and learn more to better understand these scripting languages that are being presented as part of this solution. I am a B.S. Computer Science in the Philippines and I've been a programmer since. I am your typical IT specialist (jack-of-all trades) with the following background: * Multimedia developer (technology no longer available) * Help authoring specialists (InstallShield) * Web developer (Macromededia ColdFusion, Classic ASP and .Net (vba/c#)) * Data specialist (SQL Integration Services, and Reporting Services) * Business Intelligence Developer using Microsoft Power Plastform (Power Apps, Power Automate and Power BI) I am currently working as a Power Apps Developer processing remote tasks for a US client. Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) c GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics \\[V_{dc} = \\frac{V_m}{\\pi}\\] \\[V_{rms} = \\frac{V_m}{\\sqrt{2}}\\]","title":"Introduction"},{"location":"#introduction","text":"This is the website for Meynard Gilhang's Physics activities. This is my first time to use GitHub and i'm still grasping for the new web technologies and I'm trying to adapt and learn more to better understand these scripting languages that are being presented as part of this solution. I am a B.S. Computer Science in the Philippines and I've been a programmer since. I am your typical IT specialist (jack-of-all trades) with the following background: * Multimedia developer (technology no longer available) * Help authoring specialists (InstallShield) * Web developer (Macromededia ColdFusion, Classic ASP and .Net (vba/c#)) * Data specialist (SQL Integration Services, and Reporting Services) * Business Intelligence Developer using Microsoft Power Plastform (Power Apps, Power Automate and Power BI) I am currently working as a Power Apps Developer processing remote tasks for a US client.","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) c GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics \\[V_{dc} = \\frac{V_m}{\\pi}\\] \\[V_{rms} = \\frac{V_m}{\\sqrt{2}}\\]","title":"Where can I find the problems?"},{"location":"Physics/1%20Mechanics/P1/1.AngleOfProjection/","text":"Angle of Projection The angle of projection in projectile motion is a critical parameter that affects the trajectory, range, time of flight, and maximum height of a projectile. The angle of projection, combined with initial velocity, gravitational acceleration, and launch height, determines the path followed by the projectile. Let's break down how these parameters interact and the different sets of solutions that can arise: Initial Velocity v\u2080: Definition: The speed at which the projectile is launched. Impact: Affects the range and maximum height. For a given angle, increasing the initial velocity increases both the range and the height of the projectile. Gravitational Acceleration g: Definition: The acceleration due to gravity, typically \\(9.81 , m/s^2\\) on Earth. Impact: Acts downward, affecting the time of flight and the shape of the trajectory. It pulls the projectile downward, creating a parabolic path. Launch Height h: Definition: The height from which the projectile is launched relative to the landing point. Impact: Influences the time the projectile stays in the air and the range. A higher launch point allows for a longer flight time and potentially greater range, depending on the angle of projection.","title":"Angle of Projection"},{"location":"Physics/1%20Mechanics/P1/1.AngleOfProjection/#angle-of-projection","text":"The angle of projection in projectile motion is a critical parameter that affects the trajectory, range, time of flight, and maximum height of a projectile. The angle of projection, combined with initial velocity, gravitational acceleration, and launch height, determines the path followed by the projectile. Let's break down how these parameters interact and the different sets of solutions that can arise: Initial Velocity v\u2080: Definition: The speed at which the projectile is launched. Impact: Affects the range and maximum height. For a given angle, increasing the initial velocity increases both the range and the height of the projectile. Gravitational Acceleration g: Definition: The acceleration due to gravity, typically \\(9.81 , m/s^2\\) on Earth. Impact: Acts downward, affecting the time of flight and the shape of the trajectory. It pulls the projectile downward, creating a parabolic path. Launch Height h: Definition: The height from which the projectile is launched relative to the landing point. Impact: Influences the time the projectile stays in the air and the range. A higher launch point allows for a longer flight time and potentially greater range, depending on the angle of projection.","title":"Angle of Projection"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/","text":"Basic Physics of Projectile Motion Equations of Motion: When a projectile is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal, its motion can be described using the following equations: Horizontal Range: \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\] Maximum Height: \\[H = \\frac{v_0^2 \\sin^2(\\theta)}{2g}\\] Time of Flight: \\[T = \\frac{2v_0 \\sin(\\theta)}{g}\\] Here, \\(g\\) is the acceleration due to gravity (approximately \\(9.81 , \\text{m/s}^2\\) on Earth). Range and Angle of Projection: The range \\(R\\) is maximized when the angle of projection \\(\\theta\\) is \\(45^\\circ\\) , assuming no air resistance. This is because the function \\(\\sin(2\\theta)\\) is maximized at \\(2\\theta = 90^\\circ\\) Optimal Angle for Maximum Range Theory: For a projectile launched on a flat surface (i.e., launch height = landing height), the optimal angle for maximum range is 45 degrees. This is because the horizontal and vertical components of the initial velocity are equal, maximizing the distance. With Launch Height: If the launch height is above the landing height, the angle for maximum range is slightly less than 45 degrees, as the projectile benefits from additional time in the air. Symmetric Trajectories Description: When launched from and landing on the same height, the projectile's path is symmetric around the peak. Angles: Two angles will yield the same range: \\[\\theta \\ and \\ 90^\\circ - \\theta\\] For example, angles of 30 degrees and 60 degrees will result in the same range, but different times of flight and maximum heights. Time of Flight Dependency: Depends on the vertical component of the initial velocity and the height difference between launch and landing. Calculation: For non-zero launch height, the time of flight can be found using kinematic equations that incorporate both the initial vertical velocity component and the effect of gravity. Maximum Height Calculation: Depends on the vertical component of the initial velocity and gravitational acceleration. For launch height \\(h\\) , the maximum height \\(H\\) is given by: \\[ H = h + \\frac{(v\u2080 \\sin \\theta)^2}{2g} \\] Effect of Air Resistance Real-World Consideration: Although not accounted for in basic projectile motion equations, air resistance can significantly affect the trajectory, reducing both range and height, and altering the optimal angle of projection.","title":"Basic Physics of Projectile Motion"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#basic-physics-of-projectile-motion","text":"Equations of Motion: When a projectile is launched with an initial velocity \\(v_0\\) at an angle \\(\\theta\\) from the horizontal, its motion can be described using the following equations: Horizontal Range: \\[R = \\frac{v_0^2 \\sin(2\\theta)}{g}\\] Maximum Height: \\[H = \\frac{v_0^2 \\sin^2(\\theta)}{2g}\\] Time of Flight: \\[T = \\frac{2v_0 \\sin(\\theta)}{g}\\] Here, \\(g\\) is the acceleration due to gravity (approximately \\(9.81 , \\text{m/s}^2\\) on Earth). Range and Angle of Projection: The range \\(R\\) is maximized when the angle of projection \\(\\theta\\) is \\(45^\\circ\\) , assuming no air resistance. This is because the function \\(\\sin(2\\theta)\\) is maximized at \\(2\\theta = 90^\\circ\\)","title":"Basic Physics of Projectile Motion"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#optimal-angle-for-maximum-range","text":"Theory: For a projectile launched on a flat surface (i.e., launch height = landing height), the optimal angle for maximum range is 45 degrees. This is because the horizontal and vertical components of the initial velocity are equal, maximizing the distance. With Launch Height: If the launch height is above the landing height, the angle for maximum range is slightly less than 45 degrees, as the projectile benefits from additional time in the air.","title":"Optimal Angle for Maximum Range"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#symmetric-trajectories","text":"Description: When launched from and landing on the same height, the projectile's path is symmetric around the peak. Angles: Two angles will yield the same range: \\[\\theta \\ and \\ 90^\\circ - \\theta\\] For example, angles of 30 degrees and 60 degrees will result in the same range, but different times of flight and maximum heights.","title":"Symmetric Trajectories"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#time-of-flight","text":"Dependency: Depends on the vertical component of the initial velocity and the height difference between launch and landing. Calculation: For non-zero launch height, the time of flight can be found using kinematic equations that incorporate both the initial vertical velocity component and the effect of gravity.","title":"Time of Flight"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#maximum-height","text":"Calculation: Depends on the vertical component of the initial velocity and gravitational acceleration. For launch height \\(h\\) , the maximum height \\(H\\) is given by: \\[ H = h + \\frac{(v\u2080 \\sin \\theta)^2}{2g} \\]","title":"Maximum Height"},{"location":"Physics/1%20Mechanics/P1/2.RangeAnalysis/#effect-of-air-resistance","text":"Real-World Consideration: Although not accounted for in basic projectile motion equations, air resistance can significantly affect the trajectory, reducing both range and height, and altering the optimal angle of projection.","title":"Effect of Air Resistance"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/","text":"Practical Applications Projectile motion on uneven terrain and in the presence of air resistance is common in many real-world scenarios. These factors add complexity to predicting and optimizing trajectories, requiring careful analysis and adjustments. Here are some practical applications: Military and Defense Artillery and Ballistics: Artillery shells and missiles are often launched over uneven terrain and must account for air resistance. Advanced calculations and computer simulations help predict trajectories to accurately hit targets, considering factors like wind, air density, and varying elevation. Mortars and Rockets: Similar to artillery, mortars and rockets must adjust their launch angles and velocities to account for uneven terrain and atmospheric conditions to achieve desired impact points. Sports Golf: Golfers must consider the uneven terrain of a golf course, including hills and valleys, as well as wind conditions when choosing clubs and angles to optimize their shots. Ski Jumping: Ski jumpers launch from a slope and must navigate the air while accounting for wind resistance to achieve maximum distance and optimal landing on a descending slope. Engineering and Construction Demolition Using Explosives: Controlled demolitions often require precise calculations of projectile debris to ensure safety and effectiveness, considering the complex terrain of the demolition site. Bridge and Building Design: When constructing bridges or buildings, engineers use projectile motion principles to simulate potential debris trajectories from construction activities, ensuring safety on uneven terrain. Space Exploration Lunar and Planetary Landers: Landers must be designed to account for uneven terrain on celestial bodies and thin atmospheres when planning descent trajectories for safe landings. Mars Rovers: When launching projectiles or deploying components from rovers, engineers must consider Mars' uneven terrain and thin atmosphere to ensure successful operations. Entertainment and Media Stunt Coordination: In movies and shows, stunts involving projectile motion (e.g., jumping cars or bikes) need careful planning to account for uneven surfaces and air resistance to ensure the safety of performers. Fireworks Displays: Pyrotechnicians consider wind and varying terrain to design fireworks shows that achieve desired visual effects while ensuring safety and precision. Aerospace and Aviation Aircraft Bombing: When planes drop bombs or other projectiles, pilots and systems must account for the speed of the aircraft, altitude, air resistance, and terrain below to accurately hit targets. Drone Deliveries: Drones navigating uneven urban environments must account for wind currents and obstacles when delivering packages to specific locations.","title":"Practical Applications"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#practical-applications","text":"Projectile motion on uneven terrain and in the presence of air resistance is common in many real-world scenarios. These factors add complexity to predicting and optimizing trajectories, requiring careful analysis and adjustments. Here are some practical applications:","title":"Practical Applications"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#military-and-defense","text":"Artillery and Ballistics: Artillery shells and missiles are often launched over uneven terrain and must account for air resistance. Advanced calculations and computer simulations help predict trajectories to accurately hit targets, considering factors like wind, air density, and varying elevation. Mortars and Rockets: Similar to artillery, mortars and rockets must adjust their launch angles and velocities to account for uneven terrain and atmospheric conditions to achieve desired impact points.","title":"Military and Defense"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#sports","text":"Golf: Golfers must consider the uneven terrain of a golf course, including hills and valleys, as well as wind conditions when choosing clubs and angles to optimize their shots. Ski Jumping: Ski jumpers launch from a slope and must navigate the air while accounting for wind resistance to achieve maximum distance and optimal landing on a descending slope.","title":"Sports"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#engineering-and-construction","text":"Demolition Using Explosives: Controlled demolitions often require precise calculations of projectile debris to ensure safety and effectiveness, considering the complex terrain of the demolition site. Bridge and Building Design: When constructing bridges or buildings, engineers use projectile motion principles to simulate potential debris trajectories from construction activities, ensuring safety on uneven terrain.","title":"Engineering and Construction"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#space-exploration","text":"Lunar and Planetary Landers: Landers must be designed to account for uneven terrain on celestial bodies and thin atmospheres when planning descent trajectories for safe landings. Mars Rovers: When launching projectiles or deploying components from rovers, engineers must consider Mars' uneven terrain and thin atmosphere to ensure successful operations.","title":"Space Exploration"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#entertainment-and-media","text":"Stunt Coordination: In movies and shows, stunts involving projectile motion (e.g., jumping cars or bikes) need careful planning to account for uneven surfaces and air resistance to ensure the safety of performers. Fireworks Displays: Pyrotechnicians consider wind and varying terrain to design fireworks shows that achieve desired visual effects while ensuring safety and precision.","title":"Entertainment and Media"},{"location":"Physics/1%20Mechanics/P1/3.PracticalApplications/#aerospace-and-aviation","text":"Aircraft Bombing: When planes drop bombs or other projectiles, pilots and systems must account for the speed of the aircraft, altitude, air resistance, and terrain below to accurately hit targets. Drone Deliveries: Drones navigating uneven urban environments must account for wind currents and obstacles when delivering packages to specific locations.","title":"Aerospace and Aviation"},{"location":"Physics/1%20Mechanics/P1/4.Implementation/","text":"Observations based on interactive simulations Interactive tool for running simulations on Projectile Motion Focusing on one parameter and having the rest of the parameters having the same values: a. Distance traveled by a projectile, in both the vertical height and horizontal distance, are directly impacted by the initial angle of the velocity. The higher the angle, the higher the vertical distance covered. The same parameter will also result with the projectile traveling a shorter distance. b. Changing the initial velocity will have the following results: Increasing the initial velocity will result to greater distance covered both in vertical and horizontal distance. Decreasing the initial velocity will result to the projectile traveling a shorter distance in both height and range. b. Changing the initial height will have the similar results when changing initial velociy - increase in vertical height and distance covered.","title":"Observations based on interactive simulations"},{"location":"Physics/1%20Mechanics/P1/4.Implementation/#observations-based-on-interactive-simulations","text":"Interactive tool for running simulations on Projectile Motion Focusing on one parameter and having the rest of the parameters having the same values: a. Distance traveled by a projectile, in both the vertical height and horizontal distance, are directly impacted by the initial angle of the velocity. The higher the angle, the higher the vertical distance covered. The same parameter will also result with the projectile traveling a shorter distance. b. Changing the initial velocity will have the following results: Increasing the initial velocity will result to greater distance covered both in vertical and horizontal distance. Decreasing the initial velocity will result to the projectile traveling a shorter distance in both height and range. b. Changing the initial height will have the similar results when changing initial velociy - increase in vertical height and distance covered.","title":"Observations based on interactive simulations"},{"location":"Physics/1%20Mechanics/P1/5.SourceCode/","text":"Source code function calculateRangeAndMaxHeight(angle, initialHeight, initialVelocity, gravity) { const angleInRadians = angle * Math.PI / 180; const timeOfFlight = (initialVelocity * Math.sin(angleInRadians) + Math.sqrt(Math.pow(initialVelocity * Math.sin(angleInRadians), 2) + 2 * gravity * initialHeight)) / gravity; let x = []; let y = []; for (let t = 0; t <= timeOfFlight; t += 0.1) { const range = initialVelocity * Math.cos(angleInRadians) * t; const height = initialHeight + initialVelocity * Math.sin(angleInRadians) * t - 0.5 * gravity * t * t; if (height < 0) break; x.push(range); y.push(height); } return { x, y }; } function updateGraph() { const angle = document.getElementById(\"angleSlider\").value; const initialHeight = document.getElementById(\"heightSlider\").value; const gravity = parseFloat(document.getElementById(\"gravitySlider\").value); document.getElementById(\"angleValue\").innerText = angle + '\u00b0'; document.getElementById(\"heightValue\").innerText = initialHeight + ' m'; const initialVelocity = 50; // This can be adjusted const data = calculateRangeAndMaxHeight(parseFloat(angle), parseFloat(initialHeight), initialVelocity, gravity); const trace1 = { x: data.x, y: data.y, mode: 'lines+markers', name: 'Trajectory', }; const layout = { title: `Projectile Motion<br>Initial Velocity = ${initialVelocity} m/s, Angle = ${angle}\u00b0, Initial Height = ${initialHeight} m, Gravity = ${gravity} m/s\u00b2`, xaxis: { title: 'Range (m)' }, yaxis: { title: 'Height (m)', range: [0, Math.max(...data.y) + 5] }, height: 600, width: 800 }; Plotly.newPlot('graph', [trace1], layout); } updateGraph();","title":"Source code"},{"location":"Physics/1%20Mechanics/P1/5.SourceCode/#source-code","text":"function calculateRangeAndMaxHeight(angle, initialHeight, initialVelocity, gravity) { const angleInRadians = angle * Math.PI / 180; const timeOfFlight = (initialVelocity * Math.sin(angleInRadians) + Math.sqrt(Math.pow(initialVelocity * Math.sin(angleInRadians), 2) + 2 * gravity * initialHeight)) / gravity; let x = []; let y = []; for (let t = 0; t <= timeOfFlight; t += 0.1) { const range = initialVelocity * Math.cos(angleInRadians) * t; const height = initialHeight + initialVelocity * Math.sin(angleInRadians) * t - 0.5 * gravity * t * t; if (height < 0) break; x.push(range); y.push(height); } return { x, y }; } function updateGraph() { const angle = document.getElementById(\"angleSlider\").value; const initialHeight = document.getElementById(\"heightSlider\").value; const gravity = parseFloat(document.getElementById(\"gravitySlider\").value); document.getElementById(\"angleValue\").innerText = angle + '\u00b0'; document.getElementById(\"heightValue\").innerText = initialHeight + ' m'; const initialVelocity = 50; // This can be adjusted const data = calculateRangeAndMaxHeight(parseFloat(angle), parseFloat(initialHeight), initialVelocity, gravity); const trace1 = { x: data.x, y: data.y, mode: 'lines+markers', name: 'Trajectory', }; const layout = { title: `Projectile Motion<br>Initial Velocity = ${initialVelocity} m/s, Angle = ${angle}\u00b0, Initial Height = ${initialHeight} m, Gravity = ${gravity} m/s\u00b2`, xaxis: { title: 'Range (m)' }, yaxis: { title: 'Height (m)', range: [0, Math.max(...data.y) + 5] }, height: 600, width: 800 }; Plotly.newPlot('graph', [trace1], layout); } updateGraph();","title":"Source code"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/","text":"Theoretical Foundations The motion of a forced damped pendulum can be described by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = \\frac{F_0}{mL} \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\beta\\) is the damping coefficient, \\(\\omega_0^2 = \\frac{g}{L}\\) is the natural frequency of the pendulum, \\(F_0\\) is the amplitude of the driving force, \\(m\\) is the mass of the pendulum bob, \\(L\\) is the length of the pendulum, \\(\\omega\\) is the driving frequency, \\(t\\) is time. Small-Angle Approximation For small-angle oscillations, we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = \\frac{F_0}{mL} \\cos(\\omega t) \\] This is a second-order linear non-homogeneous differential equation with constant coefficients. Solution of the Homogeneous Equation The homogeneous part of the equation is: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0 \\] The characteristic equation is: \\[ r^2 + 2\\beta r + \\omega_0^2 = 0 \\] Solving for \\(r\\) , we find: \\[ r = -\\beta \\pm \\sqrt{\\beta^2 - \\omega_0^2} \\] Depending on the discriminant \\(\\beta^2 - \\omega_0^2\\) , the system can be: Overdamped \\(\\beta^2 > \\omega_0^2\\) : Two distinct real roots leading to an exponential decay without oscillations. Critically damped \\(\\beta^2 = \\omega_0^2\\) : A repeated real root leading to the fastest decay without oscillations. Underdamped \\(\\beta^2 < \\omega_0^2\\) : Complex roots leading to oscillatory decay: \\[ r = -\\beta \\pm i\\sqrt{\\omega_0^2 - \\beta^2} \\] The solution is: \\[ \\theta_h(t) = e^{-\\beta t}(A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\beta^2}\\) is the damped natural frequency. Particular Solution for the Forced System To find a particular solution \\(\\theta_p(t\\) , we assume a solution of the form: \\[ \\theta_p(t) = C \\cos(\\omega t) + D \\sin(\\omega t) \\] Substituting into the non-homogeneous equation and solving for constants \\(C\\) and \\(D\\) , we obtain: \\[ C = \\frac{F_0/mL}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta \\omega)^2}} \\] \\[ D = -\\frac{2\\beta \\omega C}{\\omega_0^2 - \\omega^2} \\] The general solution is: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] Resonance Conditions Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system \\(\\omega_0\\) . At resonance \\(\\omega \\approx \\omega_0\\) , the amplitude of oscillations becomes significantly large because the system absorbs energy most efficiently from the driving force. The implications for the system's energy are profound: Increased Amplitude: The displacement amplitude increases, which means more energy is stored in the system as potential and kinetic energy. Energy Transfer: The system can absorb more energy from the driving force, leading to increased oscillations. Potential for Damage: In practical systems, excessive amplitudes due to resonance can lead to mechanical failure or structural damage.","title":"Theoretical Foundations"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/#theoretical-foundations","text":"The motion of a forced damped pendulum can be described by the differential equation: \\[\\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\sin(\\theta) = \\frac{F_0}{mL} \\cos(\\omega t) \\] where: \\(\\theta\\) is the angular displacement, \\(\\beta\\) is the damping coefficient, \\(\\omega_0^2 = \\frac{g}{L}\\) is the natural frequency of the pendulum, \\(F_0\\) is the amplitude of the driving force, \\(m\\) is the mass of the pendulum bob, \\(L\\) is the length of the pendulum, \\(\\omega\\) is the driving frequency, \\(t\\) is time.","title":"Theoretical Foundations"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/#small-angle-approximation","text":"For small-angle oscillations, we can use the approximation \\(\\sin(\\theta) \\approx \\theta\\) . This simplifies the equation to: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = \\frac{F_0}{mL} \\cos(\\omega t) \\] This is a second-order linear non-homogeneous differential equation with constant coefficients.","title":"Small-Angle Approximation"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/#solution-of-the-homogeneous-equation","text":"The homogeneous part of the equation is: \\[ \\frac{d^2\\theta}{dt^2} + 2\\beta \\frac{d\\theta}{dt} + \\omega_0^2 \\theta = 0 \\] The characteristic equation is: \\[ r^2 + 2\\beta r + \\omega_0^2 = 0 \\] Solving for \\(r\\) , we find: \\[ r = -\\beta \\pm \\sqrt{\\beta^2 - \\omega_0^2} \\] Depending on the discriminant \\(\\beta^2 - \\omega_0^2\\) , the system can be: Overdamped \\(\\beta^2 > \\omega_0^2\\) : Two distinct real roots leading to an exponential decay without oscillations. Critically damped \\(\\beta^2 = \\omega_0^2\\) : A repeated real root leading to the fastest decay without oscillations. Underdamped \\(\\beta^2 < \\omega_0^2\\) : Complex roots leading to oscillatory decay: \\[ r = -\\beta \\pm i\\sqrt{\\omega_0^2 - \\beta^2} \\] The solution is: \\[ \\theta_h(t) = e^{-\\beta t}(A \\cos(\\omega_d t) + B \\sin(\\omega_d t)) \\] where \\(\\omega_d = \\sqrt{\\omega_0^2 - \\beta^2}\\) is the damped natural frequency.","title":"Solution of the Homogeneous Equation"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/#particular-solution-for-the-forced-system","text":"To find a particular solution \\(\\theta_p(t\\) , we assume a solution of the form: \\[ \\theta_p(t) = C \\cos(\\omega t) + D \\sin(\\omega t) \\] Substituting into the non-homogeneous equation and solving for constants \\(C\\) and \\(D\\) , we obtain: \\[ C = \\frac{F_0/mL}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (2\\beta \\omega)^2}} \\] \\[ D = -\\frac{2\\beta \\omega C}{\\omega_0^2 - \\omega^2} \\] The general solution is: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\]","title":"Particular Solution for the Forced System"},{"location":"Physics/1%20Mechanics/P2/1.TheoreticalFoundation/#resonance-conditions","text":"Resonance occurs when the driving frequency \\(\\omega\\) is close to the natural frequency of the system \\(\\omega_0\\) . At resonance \\(\\omega \\approx \\omega_0\\) , the amplitude of oscillations becomes significantly large because the system absorbs energy most efficiently from the driving force. The implications for the system's energy are profound: Increased Amplitude: The displacement amplitude increases, which means more energy is stored in the system as potential and kinetic energy. Energy Transfer: The system can absorb more energy from the driving force, leading to increased oscillations. Potential for Damage: In practical systems, excessive amplitudes due to resonance can lead to mechanical failure or structural damage.","title":"Resonance Conditions"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/","text":"Dynamics of Forced Pendulum The behavior of a forced damped pendulum is influenced by several parameters: the damping coefficient, the driving amplitude, and the driving frequency. Each of these parameters affects the pendulum's motion in distinct ways. Influence of Parameters Damping Coefficient \\(\\beta\\) - Energy Dissipation: The damping coefficient represents the rate at which energy is lost from the system, typically due to friction or air resistance. - Amplitude Reduction: Higher damping results in quicker decay of oscillations and reduces the steady-state amplitude of oscillations. - Transition to Steady State: Stronger damping hastens the transition to the steady-state response and can prevent large oscillations at or near resonance. Driving Amplitude \\(F_0\\) Energy Input: A higher driving amplitude means more energy is input into the system. Amplitude of Response: The amplitude of the pendulum's oscillations in its steady state is directly proportional to the driving amplitude. Potential for Chaos: Large driving amplitudes can lead to complex, chaotic motion as they provide enough energy to overcome damping and allow the system to explore a wider range of phase space. Driving Frequency \\(\\omega\\) Resonance: When the driving frequency is close to the natural frequency of the system, resonance can occur, leading to large amplitude oscillations. Frequency Response: The system's response amplitude and phase change significantly with different driving frequencies, especially near resonance. Transition to Chaos: Certain frequencies, particularly those far from the natural frequency or in combination with other parameters, can lead to bifurcations and chaotic behavior. Transition Between Regular and Chaotic Motion The transition between regular (periodic) and chaotic motion in a forced damped pendulum is a hallmark of nonlinear systems. It can be influenced by changes in the damping coefficient, driving amplitude, and driving frequency. Regular Motion Characterized by predictable, periodic oscillations. Occurs when the system parameters are such that the pendulum follows a stable, repeating path in its phase space. Typically observed at low driving amplitudes and frequencies away from resonance. Chaotic Motion Characterized by aperiodic, unpredictable behavior that is highly sensitive to initial conditions. Occurs when the system parameters cause the pendulum to explore a larger, more complex region of phase space. Can be triggered by increasing the driving amplitude or frequency, especially when combined with low damping. Physical Interpretation Phase Space: In regular motion, the trajectory in phase space is a closed loop, indicating periodic behavior. In chaotic motion, the trajectory fills a region of phase space, reflecting the system's sensitivity to initial conditions and lack of periodicity. Bifurcations: As parameters change, the system may undergo bifurcations, where a small change in parameters results in a qualitative change in motion (e.g., from periodic to chaotic). Energy Exchange: In chaotic regimes, energy exchange between potential and kinetic forms becomes irregular, leading to erratic motion. Real-World Implications: Understanding these transitions is crucial in engineering and physics, as it helps in designing systems that avoid chaotic behavior when stability is desired, or exploit it when randomness is beneficial (e.g., in mixing processes).","title":"Dynamics of Forced Pendulum"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#dynamics-of-forced-pendulum","text":"The behavior of a forced damped pendulum is influenced by several parameters: the damping coefficient, the driving amplitude, and the driving frequency. Each of these parameters affects the pendulum's motion in distinct ways.","title":"Dynamics of Forced Pendulum"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#influence-of-parameters","text":"","title":"Influence of Parameters"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#damping-coefficient-beta","text":"- Energy Dissipation: The damping coefficient represents the rate at which energy is lost from the system, typically due to friction or air resistance. - Amplitude Reduction: Higher damping results in quicker decay of oscillations and reduces the steady-state amplitude of oscillations. - Transition to Steady State: Stronger damping hastens the transition to the steady-state response and can prevent large oscillations at or near resonance.","title":"Damping Coefficient \\(\\beta\\)"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#driving-amplitude-f_0","text":"Energy Input: A higher driving amplitude means more energy is input into the system. Amplitude of Response: The amplitude of the pendulum's oscillations in its steady state is directly proportional to the driving amplitude. Potential for Chaos: Large driving amplitudes can lead to complex, chaotic motion as they provide enough energy to overcome damping and allow the system to explore a wider range of phase space.","title":"Driving Amplitude \\(F_0\\)"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#driving-frequency-omega","text":"Resonance: When the driving frequency is close to the natural frequency of the system, resonance can occur, leading to large amplitude oscillations. Frequency Response: The system's response amplitude and phase change significantly with different driving frequencies, especially near resonance. Transition to Chaos: Certain frequencies, particularly those far from the natural frequency or in combination with other parameters, can lead to bifurcations and chaotic behavior.","title":"Driving Frequency \\(\\omega\\)"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#transition-between-regular-and-chaotic-motion","text":"The transition between regular (periodic) and chaotic motion in a forced damped pendulum is a hallmark of nonlinear systems. It can be influenced by changes in the damping coefficient, driving amplitude, and driving frequency.","title":"Transition Between Regular and Chaotic Motion"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#regular-motion","text":"Characterized by predictable, periodic oscillations. Occurs when the system parameters are such that the pendulum follows a stable, repeating path in its phase space. Typically observed at low driving amplitudes and frequencies away from resonance.","title":"Regular Motion"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#chaotic-motion","text":"Characterized by aperiodic, unpredictable behavior that is highly sensitive to initial conditions. Occurs when the system parameters cause the pendulum to explore a larger, more complex region of phase space. Can be triggered by increasing the driving amplitude or frequency, especially when combined with low damping.","title":"Chaotic Motion"},{"location":"Physics/1%20Mechanics/P2/2.AnalysisOfDynamics/#physical-interpretation","text":"Phase Space: In regular motion, the trajectory in phase space is a closed loop, indicating periodic behavior. In chaotic motion, the trajectory fills a region of phase space, reflecting the system's sensitivity to initial conditions and lack of periodicity. Bifurcations: As parameters change, the system may undergo bifurcations, where a small change in parameters results in a qualitative change in motion (e.g., from periodic to chaotic). Energy Exchange: In chaotic regimes, energy exchange between potential and kinetic forms becomes irregular, leading to erratic motion. Real-World Implications: Understanding these transitions is crucial in engineering and physics, as it helps in designing systems that avoid chaotic behavior when stability is desired, or exploit it when randomness is beneficial (e.g., in mixing processes).","title":"Physical Interpretation"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/","text":"Real world scenarios Suspension Bridges Application: The dynamics of suspension bridges can be modeled as forced damped systems. Wind, traffic, and seismic activities act as external forces, while the structure's inherent damping properties help dissipate energy. Example: The Tacoma Narrows Bridge disaster is a classic case where insufficient damping and wind-induced resonance led to catastrophic oscillations. Seismic Isolation Systems Application: Buildings and structures are often equipped with seismic isolation systems to reduce the impact of earthquakes. These systems can be modeled as forced damped pendulums, where seismic forces are the driving force. Explanation: The damping elements in these systems absorb and dissipate seismic energy, minimizing displacement and damage. Energy Harvesting Devices Application: Devices that convert mechanical vibrations into electrical energy often rely on the principles of forced damped oscillations. Explanation: These systems use mechanical oscillators (like pendulums) to capture ambient vibrations and convert them into usable energy, with damping mechanisms optimizing energy extraction and stability. Oscillating Circuits Application: Electrical circuits with inductors, capacitors, and resistors can be analogous to mechanical forced damped oscillators. Explanation: The driving force is the input voltage, damping comes from resistive elements, and the circuit's natural frequency is determined by inductive and capacitive components. Mechanical Clocks Application: The escapement mechanism in mechanical clocks functions similarly to a forced damped pendulum. Explanation: The driving force is provided by a wound spring or weight, while damping ensures the pendulum's motion remains regular and precise for accurate timekeeping. Vehicle Suspension Systems Application: Car suspension systems are designed to absorb shocks and provide a smooth ride, modeled as forced damped oscillators. Explanation: The road surface provides the driving force, while shock absorbers (dampers) control oscillations to prevent excessive bouncing. Marine and Offshore Structures Application: Structures exposed to ocean waves, such as oil platforms, can be analyzed using the forced damped pendulum model. Explanation: Waves act as periodic driving forces, and the structure's damping characteristics determine its response to these forces. Control Systems in Engineering Application: Feedback control systems often use forced damped oscillators to stabilize and control dynamic systems. Explanation: Controllers adjust the damping and driving parameters to maintain desired system behavior.","title":"Real world scenarios"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#real-world-scenarios","text":"","title":"Real world scenarios"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#suspension-bridges","text":"Application: The dynamics of suspension bridges can be modeled as forced damped systems. Wind, traffic, and seismic activities act as external forces, while the structure's inherent damping properties help dissipate energy. Example: The Tacoma Narrows Bridge disaster is a classic case where insufficient damping and wind-induced resonance led to catastrophic oscillations.","title":"Suspension Bridges"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#seismic-isolation-systems","text":"Application: Buildings and structures are often equipped with seismic isolation systems to reduce the impact of earthquakes. These systems can be modeled as forced damped pendulums, where seismic forces are the driving force. Explanation: The damping elements in these systems absorb and dissipate seismic energy, minimizing displacement and damage.","title":"Seismic Isolation Systems"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#energy-harvesting-devices","text":"Application: Devices that convert mechanical vibrations into electrical energy often rely on the principles of forced damped oscillations. Explanation: These systems use mechanical oscillators (like pendulums) to capture ambient vibrations and convert them into usable energy, with damping mechanisms optimizing energy extraction and stability.","title":"Energy Harvesting Devices"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#oscillating-circuits","text":"Application: Electrical circuits with inductors, capacitors, and resistors can be analogous to mechanical forced damped oscillators. Explanation: The driving force is the input voltage, damping comes from resistive elements, and the circuit's natural frequency is determined by inductive and capacitive components.","title":"Oscillating Circuits"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#mechanical-clocks","text":"Application: The escapement mechanism in mechanical clocks functions similarly to a forced damped pendulum. Explanation: The driving force is provided by a wound spring or weight, while damping ensures the pendulum's motion remains regular and precise for accurate timekeeping.","title":"Mechanical Clocks"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#vehicle-suspension-systems","text":"Application: Car suspension systems are designed to absorb shocks and provide a smooth ride, modeled as forced damped oscillators. Explanation: The road surface provides the driving force, while shock absorbers (dampers) control oscillations to prevent excessive bouncing.","title":"Vehicle Suspension Systems"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#marine-and-offshore-structures","text":"Application: Structures exposed to ocean waves, such as oil platforms, can be analyzed using the forced damped pendulum model. Explanation: Waves act as periodic driving forces, and the structure's damping characteristics determine its response to these forces.","title":"Marine and Offshore Structures"},{"location":"Physics/1%20Mechanics/P2/3.Scenarios/#control-systems-in-engineering","text":"Application: Feedback control systems often use forced damped oscillators to stabilize and control dynamic systems. Explanation: Controllers adjust the damping and driving parameters to maintain desired system behavior.","title":"Control Systems in Engineering"},{"location":"Physics/1%20Mechanics/P2/4.Implementation/","text":"Implementation Simulate the motion of a forced damped pendulum using 3 variables Parameters: \\(\\beta\\) Damping Coefficient \\(F_0\\) Driving Amplitude \\(\\omega\\) Driving Frequency Simulate the motion of a forced damped pendulum using 7 variables Parameters: \\(g\\) gravitational constant \\(L\\) pendulum length \\(\\beta\\) Damping Coefficient \\(F_0\\) Driving Amplitude \\(\\omega\\) Driving Frequency \\(dt\\) time step \\(T\\) total simulation time","title":"Implementation"},{"location":"Physics/1%20Mechanics/P2/4.Implementation/#implementation","text":"Simulate the motion of a forced damped pendulum using 3 variables Parameters: \\(\\beta\\) Damping Coefficient \\(F_0\\) Driving Amplitude \\(\\omega\\) Driving Frequency Simulate the motion of a forced damped pendulum using 7 variables Parameters: \\(g\\) gravitational constant \\(L\\) pendulum length \\(\\beta\\) Damping Coefficient \\(F_0\\) Driving Amplitude \\(\\omega\\) Driving Frequency \\(dt\\) time step \\(T\\) total simulation time","title":"Implementation"},{"location":"Physics/1%20Mechanics/P2/5.SourceCode/","text":"Source code 3 Parameter ipt Copy codefunction simulate() { // Retrieve parameters from sliders const beta = parseFloat(document.getElementById('beta').value); const F0 = parseFloat(document.getElementById('F0').value); const omegaDrive = parseFloat(document.getElementById('omega').value); // Update display of parameter values document.getElementById('betaValue').innerText = beta.toFixed(2); document.getElementById('F0Value').innerText = F0.toFixed(1); document.getElementById('omegaValue').innerText = omegaDrive.toFixed(1); // Constants const g = 9.81; // gravity const L = 1.0; // length of pendulum // Time parameters const dt = 0.01; // time step const totalTime = 100; // total simulation time const poincareInterval = Math.PI * 2 / omegaDrive; // interval for Poincar\u00e9 section // Initialize variables let theta = 0.1; // initial angle let omega = 0.0; // initial angular velocity let time = 0.0; // Data arrays for phase diagram and Poincar\u00e9 section let phaseData = []; let poincareData = []; // Simulation loop while (time < totalTime) { // Calculate angular acceleration const alpha = -(g / L) * Math.sin(theta) - beta * omega + (F0 / L) * Math.cos(omegaDrive * time); // Update angular velocity and angle omega += alpha * dt; theta += omega * dt; // Record phase data phaseData.push({ x: theta, y: omega }); // Record Poincar\u00e9 section data at driving period intervals if (Math.abs((time % poincareInterval) - poincareInterval) < dt) { poincareData.push({ x: theta, y: omega }); } // Increment time time += dt; } // Plot phase diagram using Plotly Plotly.newPlot('phaseDiagram', [{ x: phaseData.map(point => point.x), y: phaseData.map(point => point.y), mode: 'lines', name: 'Phase Diagram' }], { title: 'Phase Diagram', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); // Plot Poincar\u00e9 section using Plotly Plotly.newPlot('poincareSection', [{ x: poincareData.map(point => point.x), y: poincareData.map(point => point.y), mode: 'markers', name: 'Poincar\u00e9 Section' }], { title: 'Poincar\u00e9 Section', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); } // Initial simulation on page load simulate(); 7 Parameter function simulate() { // Retrieve parameters from inputs const g = parseFloat(document.getElementById('g').value); const L = parseFloat(document.getElementById('L').value); const beta = parseFloat(document.getElementById('beta').value); const F0 = parseFloat(document.getElementById('F0').value); const omegaDrive = parseFloat(document.getElementById('omegaDrive').value); const dt = parseFloat(document.getElementById('dt').value); const totalTime = parseFloat(document.getElementById('totalTime').value); // Initialize variables let theta = 0.1; // initial angle let omega = 0.0; // initial angular velocity let time = 0.0; // Data arrays for phase diagram and Poincar\u00e9 section let phaseData = []; let poincareData = []; // Simulation loop while (time < totalTime) { // Calculate angular acceleration const alpha = -(g / L) * Math.sin(theta) - beta * omega + (F0 / L) * Math.cos(omegaDrive * time); // Update angular velocity and angle omega += alpha * dt; theta += omega * dt; // Record phase data phaseData.push({ x: theta, y: omega }); // Record Poincar\u00e9 section data at driving period intervals const poincareInterval = Math.PI * 2 / omegaDrive; if (Math.abs((time % poincareInterval) - poincareInterval) < dt) { poincareData.push({ x: theta, y: omega }); } // Increment time time += dt; } // Plot phase diagram using Plotly Plotly.newPlot('phaseDiagram', [{ x: phaseData.map(point => point.x), y: phaseData.map(point => point.y), mode: 'lines', name: 'Phase Diagram' }], { title: 'Phase Diagram', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); // Plot Poincar\u00e9 section using Plotly Plotly.newPlot('poincareSection', [{ x: poincareData.map(point => point.x), y: poincareData.map(point => point.y), mode: 'markers', name: 'Poincar\u00e9 Section' }], { title: 'Poincar\u00e9 Section', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); } // Initial simulation on page load simulate();","title":"Source code"},{"location":"Physics/1%20Mechanics/P2/5.SourceCode/#source-code","text":"3 Parameter ipt Copy codefunction simulate() { // Retrieve parameters from sliders const beta = parseFloat(document.getElementById('beta').value); const F0 = parseFloat(document.getElementById('F0').value); const omegaDrive = parseFloat(document.getElementById('omega').value); // Update display of parameter values document.getElementById('betaValue').innerText = beta.toFixed(2); document.getElementById('F0Value').innerText = F0.toFixed(1); document.getElementById('omegaValue').innerText = omegaDrive.toFixed(1); // Constants const g = 9.81; // gravity const L = 1.0; // length of pendulum // Time parameters const dt = 0.01; // time step const totalTime = 100; // total simulation time const poincareInterval = Math.PI * 2 / omegaDrive; // interval for Poincar\u00e9 section // Initialize variables let theta = 0.1; // initial angle let omega = 0.0; // initial angular velocity let time = 0.0; // Data arrays for phase diagram and Poincar\u00e9 section let phaseData = []; let poincareData = []; // Simulation loop while (time < totalTime) { // Calculate angular acceleration const alpha = -(g / L) * Math.sin(theta) - beta * omega + (F0 / L) * Math.cos(omegaDrive * time); // Update angular velocity and angle omega += alpha * dt; theta += omega * dt; // Record phase data phaseData.push({ x: theta, y: omega }); // Record Poincar\u00e9 section data at driving period intervals if (Math.abs((time % poincareInterval) - poincareInterval) < dt) { poincareData.push({ x: theta, y: omega }); } // Increment time time += dt; } // Plot phase diagram using Plotly Plotly.newPlot('phaseDiagram', [{ x: phaseData.map(point => point.x), y: phaseData.map(point => point.y), mode: 'lines', name: 'Phase Diagram' }], { title: 'Phase Diagram', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); // Plot Poincar\u00e9 section using Plotly Plotly.newPlot('poincareSection', [{ x: poincareData.map(point => point.x), y: poincareData.map(point => point.y), mode: 'markers', name: 'Poincar\u00e9 Section' }], { title: 'Poincar\u00e9 Section', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); } // Initial simulation on page load simulate(); 7 Parameter function simulate() { // Retrieve parameters from inputs const g = parseFloat(document.getElementById('g').value); const L = parseFloat(document.getElementById('L').value); const beta = parseFloat(document.getElementById('beta').value); const F0 = parseFloat(document.getElementById('F0').value); const omegaDrive = parseFloat(document.getElementById('omegaDrive').value); const dt = parseFloat(document.getElementById('dt').value); const totalTime = parseFloat(document.getElementById('totalTime').value); // Initialize variables let theta = 0.1; // initial angle let omega = 0.0; // initial angular velocity let time = 0.0; // Data arrays for phase diagram and Poincar\u00e9 section let phaseData = []; let poincareData = []; // Simulation loop while (time < totalTime) { // Calculate angular acceleration const alpha = -(g / L) * Math.sin(theta) - beta * omega + (F0 / L) * Math.cos(omegaDrive * time); // Update angular velocity and angle omega += alpha * dt; theta += omega * dt; // Record phase data phaseData.push({ x: theta, y: omega }); // Record Poincar\u00e9 section data at driving period intervals const poincareInterval = Math.PI * 2 / omegaDrive; if (Math.abs((time % poincareInterval) - poincareInterval) < dt) { poincareData.push({ x: theta, y: omega }); } // Increment time time += dt; } // Plot phase diagram using Plotly Plotly.newPlot('phaseDiagram', [{ x: phaseData.map(point => point.x), y: phaseData.map(point => point.y), mode: 'lines', name: 'Phase Diagram' }], { title: 'Phase Diagram', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); // Plot Poincar\u00e9 section using Plotly Plotly.newPlot('poincareSection', [{ x: poincareData.map(point => point.x), y: poincareData.map(point => point.y), mode: 'markers', name: 'Poincar\u00e9 Section' }], { title: 'Poincar\u00e9 Section', xaxis: { title: 'Theta (rad)' }, yaxis: { title: 'Omega (rad/s)' } }); } // Initial simulation on page load simulate();","title":"Source code"},{"location":"Physics/2%20Gravity/P1/Gravity/","text":"Gravity Newton's Law of Universal Gravitation \\[ F = \\frac{G \\cdot m_1 \\cdot m_2}{r^2} \\] where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant \\(m_1\\) and \\(m_2\\) are the masses of the two objects \\(r\\) is the distance between the centers of the two objects Centripetal Force for Circular Orbit The centripetal force needed to keep a body in circular motion is given by: \\[ F = \\frac{m \\cdot v^2}{r} \\] where: \\(m\\) is the mass of the orbiting object \\(v\\) is the orbital velocity \\(r\\) is the orbital radius Equating the Gravitational and Centripetal Forces \\[ \\frac{G \\cdot M \\cdot m}{r^2} = \\frac{m \\cdot v^2}{r} \\] Simplifying, we obtain: \\[ G \\cdot M = v^2 \\cdot r \\] Gravitational Force The gravitational force is a force of attraction between two masses. It is expressed by Newton's law of universal gravitation: \\[ F = \\frac{G \\cdot M \\cdot m}{r^2} \\] Where: \\(G\\) : Gravitational Constant fundamental constant of nature that describes the strength of the gravitational force. Its approximate value is \\(6.674 \\times 10^{-11}, {Nm}^2/\\text{kg}^2\\) . \\(M\\) and \\(m\\) : Masses The masses of the two objects experiencing the gravitational attraction. They could be any objects, like the Earth and the Moon, or the Earth and an apple. \\(r\\) : Distance The distance between the centers of the two masses. As the distance increases, the gravitational force decreases, following the inverse square law. \\(F\\) : Gravitational Force The magnitude of the force of attraction between the two masses. Centripetal Force Centripetal force is the force that keeps an object moving in a circular path. It is directed towards the center of the circle. \\[ F = \\frac{m \\cdot v^2}{r} \\] Where: \\(m\\) : Mass The mass of the object moving in the circular path. \\(v\\) : Velocity The tangential velocity of the object as it moves along the circular path. Higher velocity requires a greater centripetal force to maintain circular motion. \\(r\\) : Radius The radius of the circular path. \\(F\\) : Centripetal Force The required force to keep the object in circular motion, pointing towards the center of the circle. Gravitational force acts between two masses and depends on their masses and the distance between them. Centripetal force acts on an object moving in a circle and depends on its mass, velocity, and the radius of the circle. In both cases, these forces arise from different contexts but are integral to understanding the motion of bodies under gravity, especially in celestial mechanics where both play significant roles in defining orbits and trajectories. Relating Velocity to Orbital Period The orbital velocity \\(v\\) is related to the period \\(T\\) by the circumference of the orbit: \\[ v = \\frac{2\\pi r}{T} \\] Substituting for \\(v\\) : \\[ G \\cdot M = \\left(\\frac{2\\pi r}{T}\\right)^2 \\cdot r \\] Solving for \\(T^2\\) : \\[ GM = \\frac{4\\pi^2 r^3}{T^2} \\] \\[ T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3 \\] This equation is known as Kepler's third law for circular orbits: \\(T^2 \\propto r^3\\) . Implications in Astronomy Calculating Planetary Masses: By observing the orbital period and radius of a moon or satellite around a planet, astronomers can calculate the mass of the planet. This is particularly useful where direct measurement is difficult. Determining Distances: The relationship helps in determining the distance of celestial bodies. If the mass of the central body is known, and the orbital period can be measured, the orbital radius can be calculated. Kepler\u2019s Laws: This derivation is essentially a mathematical explanation of Kepler's third law. It tells us that, for a given central body (like the Sun), the ratio \\(T^2/r^3\\) is constant for all orbiting bodies. Real-World Examples Moon's Orbit around Earth: By measuring the Moon's orbital period and radius, the Earth's mass can be estimated. This is a primary example of applying the derived relationship in practice. Planets in the Solar System The relationship allows scientists to confirm that planets orbit faster when closer to the Sun, obeying \\(T^2 \\propto r^3\\) . Observations of Jupiter's moons, for instance, helped calculate Jupiter's mass through these principles, even before modern technology allowed us to visit the planet. In summary, this relationship forms a crucial part of celestial mechanics and is fundamental to our understanding of orbital dynamics. It plays a vital role in the field of astronomy for calculating masses and distances, thereby enhancing our understanding of planetary systems, both in our Solar System and beyond.","title":"Gravity"},{"location":"Physics/2%20Gravity/P1/Gravity/#gravity","text":"","title":"Gravity"},{"location":"Physics/2%20Gravity/P1/Gravity/#newtons-law-of-universal-gravitation","text":"\\[ F = \\frac{G \\cdot m_1 \\cdot m_2}{r^2} \\] where: \\(F\\) is the gravitational force \\(G\\) is the gravitational constant \\(m_1\\) and \\(m_2\\) are the masses of the two objects \\(r\\) is the distance between the centers of the two objects Centripetal Force for Circular Orbit The centripetal force needed to keep a body in circular motion is given by: \\[ F = \\frac{m \\cdot v^2}{r} \\] where: \\(m\\) is the mass of the orbiting object \\(v\\) is the orbital velocity \\(r\\) is the orbital radius Equating the Gravitational and Centripetal Forces \\[ \\frac{G \\cdot M \\cdot m}{r^2} = \\frac{m \\cdot v^2}{r} \\] Simplifying, we obtain: \\[ G \\cdot M = v^2 \\cdot r \\]","title":"Newton's Law of Universal Gravitation"},{"location":"Physics/2%20Gravity/P1/Gravity/#gravitational-force","text":"The gravitational force is a force of attraction between two masses. It is expressed by Newton's law of universal gravitation: \\[ F = \\frac{G \\cdot M \\cdot m}{r^2} \\] Where: \\(G\\) : Gravitational Constant fundamental constant of nature that describes the strength of the gravitational force. Its approximate value is \\(6.674 \\times 10^{-11}, {Nm}^2/\\text{kg}^2\\) . \\(M\\) and \\(m\\) : Masses The masses of the two objects experiencing the gravitational attraction. They could be any objects, like the Earth and the Moon, or the Earth and an apple. \\(r\\) : Distance The distance between the centers of the two masses. As the distance increases, the gravitational force decreases, following the inverse square law. \\(F\\) : Gravitational Force The magnitude of the force of attraction between the two masses.","title":"Gravitational Force"},{"location":"Physics/2%20Gravity/P1/Gravity/#centripetal-force","text":"Centripetal force is the force that keeps an object moving in a circular path. It is directed towards the center of the circle. \\[ F = \\frac{m \\cdot v^2}{r} \\] Where: \\(m\\) : Mass The mass of the object moving in the circular path. \\(v\\) : Velocity The tangential velocity of the object as it moves along the circular path. Higher velocity requires a greater centripetal force to maintain circular motion. \\(r\\) : Radius The radius of the circular path. \\(F\\) : Centripetal Force The required force to keep the object in circular motion, pointing towards the center of the circle. Gravitational force acts between two masses and depends on their masses and the distance between them. Centripetal force acts on an object moving in a circle and depends on its mass, velocity, and the radius of the circle. In both cases, these forces arise from different contexts but are integral to understanding the motion of bodies under gravity, especially in celestial mechanics where both play significant roles in defining orbits and trajectories.","title":"Centripetal Force"},{"location":"Physics/2%20Gravity/P1/Gravity/#relating-velocity-to-orbital-period","text":"The orbital velocity \\(v\\) is related to the period \\(T\\) by the circumference of the orbit: \\[ v = \\frac{2\\pi r}{T} \\] Substituting for \\(v\\) : \\[ G \\cdot M = \\left(\\frac{2\\pi r}{T}\\right)^2 \\cdot r \\] Solving for \\(T^2\\) : \\[ GM = \\frac{4\\pi^2 r^3}{T^2} \\] \\[ T^2 = \\frac{4\\pi^2}{GM} \\cdot r^3 \\] This equation is known as Kepler's third law for circular orbits: \\(T^2 \\propto r^3\\) .","title":"Relating Velocity to Orbital Period"},{"location":"Physics/2%20Gravity/P1/Gravity/#implications-in-astronomy","text":"Calculating Planetary Masses: By observing the orbital period and radius of a moon or satellite around a planet, astronomers can calculate the mass of the planet. This is particularly useful where direct measurement is difficult. Determining Distances: The relationship helps in determining the distance of celestial bodies. If the mass of the central body is known, and the orbital period can be measured, the orbital radius can be calculated. Kepler\u2019s Laws: This derivation is essentially a mathematical explanation of Kepler's third law. It tells us that, for a given central body (like the Sun), the ratio \\(T^2/r^3\\) is constant for all orbiting bodies.","title":"Implications in Astronomy"},{"location":"Physics/2%20Gravity/P1/Gravity/#real-world-examples","text":"Moon's Orbit around Earth: By measuring the Moon's orbital period and radius, the Earth's mass can be estimated. This is a primary example of applying the derived relationship in practice.","title":"Real-World Examples"},{"location":"Physics/2%20Gravity/P1/Gravity/#planets-in-the-solar-system","text":"The relationship allows scientists to confirm that planets orbit faster when closer to the Sun, obeying \\(T^2 \\propto r^3\\) . Observations of Jupiter's moons, for instance, helped calculate Jupiter's mass through these principles, even before modern technology allowed us to visit the planet. In summary, this relationship forms a crucial part of celestial mechanics and is fundamental to our understanding of orbital dynamics. It plays a vital role in the field of astronomy for calculating masses and distances, thereby enhancing our understanding of planetary systems, both in our Solar System and beyond.","title":"Planets in the Solar System"},{"location":"Physics/2%20Gravity/P1/Implementation/","text":"Simulations import plotly.graph_objects as go import pandas as pd # Data for the planets in the solar system data = { \"Planet\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"], \"Orbital Radius (AU)\": [0.39, 0.72, 1.00, 1.52, 5.20, 9.58, 19.20, 30.05], \"Orbital Period (years)\": [0.24, 0.62, 1.00, 1.88, 11.86, 29.46, 84.01, 164.79] } # Convert data to a DataFrame df = pd.DataFrame(data) # Calculate the square of the orbital period and the cube of the orbital radius df[\"Orbital Period Squared (years\u00b2)\"] = df[\"Orbital Period (years)\"]**2 df[\"Orbital Radius Cubed (AU\u00b3)\"] = df[\"Orbital Radius (AU)\"]**3 # Create the figure fig = go.Figure() # Add a scatter trace for the planets fig.add_trace(go.Scatter( x=df[\"Orbital Radius Cubed (AU\u00b3)\"], y=df[\"Orbital Period Squared (years\u00b2)\"], mode='markers+text', text=df[\"Planet\"], textposition='top center', name='Planets', marker=dict(size=10) )) # Add a line trace from the origin to each planet's data point for i, row in df.iterrows(): fig.add_trace(go.Scatter( x=[0, row[\"Orbital Radius Cubed (AU\u00b3)\"]], y=[0, row[\"Orbital Period Squared (years\u00b2)\"]], mode='lines', line=dict(dash='dot'), name=f'Line to {row[\"Planet\"]}' )) # Update layout for logarithmic axes fig.update_layout( title=\"Kepler's Third Law: Lines from Origin to Planets (Logarithmic Scale)\", xaxis_title='Orbital Radius Cubed (AU\u00b3) [Log Scale]', yaxis_title='Orbital Period Squared (years\u00b2) [Log Scale]', xaxis_type=\"log\", yaxis_type=\"log\", showlegend=False, margin=dict(l=20, r=20, t=30, b=20) ) # Show the plot fig.show() fig.write_html('p1_gravity.html', include_plotlyjs='cdn')","title":"Simulations"},{"location":"Physics/2%20Gravity/P1/Implementation/#simulations","text":"import plotly.graph_objects as go import pandas as pd # Data for the planets in the solar system data = { \"Planet\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"], \"Orbital Radius (AU)\": [0.39, 0.72, 1.00, 1.52, 5.20, 9.58, 19.20, 30.05], \"Orbital Period (years)\": [0.24, 0.62, 1.00, 1.88, 11.86, 29.46, 84.01, 164.79] } # Convert data to a DataFrame df = pd.DataFrame(data) # Calculate the square of the orbital period and the cube of the orbital radius df[\"Orbital Period Squared (years\u00b2)\"] = df[\"Orbital Period (years)\"]**2 df[\"Orbital Radius Cubed (AU\u00b3)\"] = df[\"Orbital Radius (AU)\"]**3 # Create the figure fig = go.Figure() # Add a scatter trace for the planets fig.add_trace(go.Scatter( x=df[\"Orbital Radius Cubed (AU\u00b3)\"], y=df[\"Orbital Period Squared (years\u00b2)\"], mode='markers+text', text=df[\"Planet\"], textposition='top center', name='Planets', marker=dict(size=10) )) # Add a line trace from the origin to each planet's data point for i, row in df.iterrows(): fig.add_trace(go.Scatter( x=[0, row[\"Orbital Radius Cubed (AU\u00b3)\"]], y=[0, row[\"Orbital Period Squared (years\u00b2)\"]], mode='lines', line=dict(dash='dot'), name=f'Line to {row[\"Planet\"]}' )) # Update layout for logarithmic axes fig.update_layout( title=\"Kepler's Third Law: Lines from Origin to Planets (Logarithmic Scale)\", xaxis_title='Orbital Radius Cubed (AU\u00b3) [Log Scale]', yaxis_title='Orbital Period Squared (years\u00b2) [Log Scale]', xaxis_type=\"log\", yaxis_type=\"log\", showlegend=False, margin=dict(l=20, r=20, t=30, b=20) ) # Show the plot fig.show() fig.write_html('p1_gravity.html', include_plotlyjs='cdn')","title":"Simulations"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/","text":"Background The concepts of first, second, and third cosmic velocities are fundamental in celestial mechanics and space exploration. They describe the velocities needed for various types of orbital and escape maneuvers around celestial bodies. Let's define them and delve into the mathematical derivations and their importance. Definitions First Cosmic Velocity (Orbital Velocity):The minimum velocity an object must have to enter a stable, circular orbit around a celestial body without additional propulsion. For Earth, this is often referred to as \"orbital velocity.\" Second Cosmic Velocity (Escape Velocity):The minimum velocity an object must achieve to break free from a celestial body's gravitational pull without further propulsion. It allows the object to escape the gravitational influence entirely. Third Cosmic Velocity (Parabolic or Hyperbolic Trajectory Velocity):The velocity necessary to escape the gravitational field of a primary celestial body and enter a trajectory influenced by another celestial body or the solar system's gravity. This is relevant for missions leaving the solar system. Mathematical Derivations First Cosmic Velocity \\(v_1\\) \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] \\(G\\) is the gravitational constant \\(6.674 \\times 10^{-11}\\) , \\(\\text{m}^3,\\text{kg}^{-1},\\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body \\(r\\) is the radius (distance from the center of the body to the object) Second Cosmic Velocity \\((v_2)\\) \\[ v_2 = \\sqrt{2} \\times v_1 = \\sqrt{\\frac{2GM}{r}} \\] This formula comes from setting the kinetic energy equal to the potential energy needed to reach infinity. Third Cosmic Velocity \\((v_3)\\) \\[ v_3 = \\sqrt{\\frac{2G(M+m)}{r}} \\] \\(m\\) is the mass of the additional celestial body to be considered if escaping a system of bodies. Calculation for Different Celestial Bodies Let's calculate these velocities for Earth, Mars, and Jupiter. Importance in Space Exploration Launching Satellites Reaching the first cosmic velocity is crucial for placing satellites into orbit. It allows them to remain stable without falling back to Earth. Missions to Other Planets: Achieving the second cosmic velocity is necessary for spacecraft to leave Earth's influence and travel to other planets or celestial bodies. Interstellar Travel The third cosmic velocity becomes significant for missions aiming to leave the solar system, such as the Voyager missions. Cosmic velocities represent key thresholds for objects navigating the gravitational fields of celestial bodies, influencing various aspects of space exploration. The first cosmic velocity allows an object to orbit around a body, the second enables escape from its gravitational pull, and the third facilitates departure from a planetary system. Cosmic Velocities Definition First Cosmic Velocity: It is the orbital velocity, necessary for an object to maintain orbit around a celestial body. In Earth's case, this velocity is approximately 7.9 km/s, allowing satellites to orbit the planet without falling away. Second Cosmic Velocity: Known as escape velocity, this is the minimum speed required for an object to break free from the gravitational influence of a celestial body. For Earth, it is about 11.2km/s. Third Cosmic Velocity: This velocity is needed to leave the gravitational field of a planetary system, such as the Solar System, and is about 16.7 km/s from Earth's surface. Mathematical Derivation and Parameters The first cosmic velocity, \\(v_1\\) , is derived using the formula: \\[v_1 = \\sqrt{\\frac{GM}{R}}\\] where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the celestial body \\(R\\) is its radius 3 The second cosmic velocity, \\(v_2\\) , is found by equating the kinetic energy of an object with its potential energy at infinity: \\[v_2 = \\sqrt{\\frac{2GM}{R}}\\] The third cosmic velocity involves considering the velocity needed to escape the gravitational potential of a larger system, such as the Sun, and can be calculated using similar energy conservation principles 3. Calculations for Different Celestial Bodies To calculate these velocities for different planets: For Mars, the first cosmic velocity is about 3.55 km/s due to Mars' smaller mass and radius compared to Earth. For Jupiter, the first cosmic velocity is approximately 42.1 km/s, reflecting Jupiter's much larger mass and radius. For the Sun (to escape from its gravitational field), the second cosmic velocity is about 618 km/s. Importance in Space Exploration These velocities are crucial for several space-related activities: Satellite Launches: The first cosmic velocity ensures satellites maintain orbit around Earth or other planets. Interplanetary Missions: The second cosmic velocity is vital for spacecraft to escape Earth's gravitational pull and travel to other planets. Potential Interstellar Travel: Achieving escape velocities high enough to leave a planetary system (third cosmic velocity) is a significant challenge for interstellar missions. Visualization Visualizing these velocities involves depicting the trajectory of objects as they achieve these critical speeds: Orbiting Satellites: For Earth orbit, objects follow curved paths around the planet. Escape Trajectories: Objects leaving planetary systems follow hyperbolic trajectories, escaping the gravitational influence.","title":"Background"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#background","text":"The concepts of first, second, and third cosmic velocities are fundamental in celestial mechanics and space exploration. They describe the velocities needed for various types of orbital and escape maneuvers around celestial bodies. Let's define them and delve into the mathematical derivations and their importance.","title":"Background"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#definitions","text":"First Cosmic Velocity (Orbital Velocity):The minimum velocity an object must have to enter a stable, circular orbit around a celestial body without additional propulsion. For Earth, this is often referred to as \"orbital velocity.\" Second Cosmic Velocity (Escape Velocity):The minimum velocity an object must achieve to break free from a celestial body's gravitational pull without further propulsion. It allows the object to escape the gravitational influence entirely. Third Cosmic Velocity (Parabolic or Hyperbolic Trajectory Velocity):The velocity necessary to escape the gravitational field of a primary celestial body and enter a trajectory influenced by another celestial body or the solar system's gravity. This is relevant for missions leaving the solar system.","title":"Definitions"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#mathematical-derivations","text":"First Cosmic Velocity \\(v_1\\) \\[ v_1 = \\sqrt{\\frac{GM}{r}} \\] \\(G\\) is the gravitational constant \\(6.674 \\times 10^{-11}\\) , \\(\\text{m}^3,\\text{kg}^{-1},\\text{s}^{-2}\\) \\(M\\) is the mass of the celestial body \\(r\\) is the radius (distance from the center of the body to the object) Second Cosmic Velocity \\((v_2)\\) \\[ v_2 = \\sqrt{2} \\times v_1 = \\sqrt{\\frac{2GM}{r}} \\] This formula comes from setting the kinetic energy equal to the potential energy needed to reach infinity. Third Cosmic Velocity \\((v_3)\\) \\[ v_3 = \\sqrt{\\frac{2G(M+m)}{r}} \\] \\(m\\) is the mass of the additional celestial body to be considered if escaping a system of bodies.","title":"Mathematical Derivations"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#calculation-for-different-celestial-bodies","text":"Let's calculate these velocities for Earth, Mars, and Jupiter.","title":"Calculation for Different Celestial Bodies"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#importance-in-space-exploration","text":"","title":"Importance in Space Exploration"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#launching-satellites","text":"Reaching the first cosmic velocity is crucial for placing satellites into orbit. It allows them to remain stable without falling back to Earth. Missions to Other Planets: Achieving the second cosmic velocity is necessary for spacecraft to leave Earth's influence and travel to other planets or celestial bodies.","title":"Launching Satellites"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#interstellar-travel","text":"The third cosmic velocity becomes significant for missions aiming to leave the solar system, such as the Voyager missions. Cosmic velocities represent key thresholds for objects navigating the gravitational fields of celestial bodies, influencing various aspects of space exploration. The first cosmic velocity allows an object to orbit around a body, the second enables escape from its gravitational pull, and the third facilitates departure from a planetary system. Cosmic Velocities Definition First Cosmic Velocity: It is the orbital velocity, necessary for an object to maintain orbit around a celestial body. In Earth's case, this velocity is approximately 7.9 km/s, allowing satellites to orbit the planet without falling away. Second Cosmic Velocity: Known as escape velocity, this is the minimum speed required for an object to break free from the gravitational influence of a celestial body. For Earth, it is about 11.2km/s. Third Cosmic Velocity: This velocity is needed to leave the gravitational field of a planetary system, such as the Solar System, and is about 16.7 km/s from Earth's surface.","title":"Interstellar Travel"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#mathematical-derivation-and-parameters","text":"The first cosmic velocity, \\(v_1\\) , is derived using the formula: \\[v_1 = \\sqrt{\\frac{GM}{R}}\\] where: \\(G\\) is the gravitational constant \\(M\\) is the mass of the celestial body \\(R\\) is its radius 3 The second cosmic velocity, \\(v_2\\) , is found by equating the kinetic energy of an object with its potential energy at infinity: \\[v_2 = \\sqrt{\\frac{2GM}{R}}\\] The third cosmic velocity involves considering the velocity needed to escape the gravitational potential of a larger system, such as the Sun, and can be calculated using similar energy conservation principles 3.","title":"Mathematical Derivation and Parameters"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#calculations-for-different-celestial-bodies","text":"To calculate these velocities for different planets: For Mars, the first cosmic velocity is about 3.55 km/s due to Mars' smaller mass and radius compared to Earth. For Jupiter, the first cosmic velocity is approximately 42.1 km/s, reflecting Jupiter's much larger mass and radius. For the Sun (to escape from its gravitational field), the second cosmic velocity is about 618 km/s. Importance in Space Exploration These velocities are crucial for several space-related activities: Satellite Launches: The first cosmic velocity ensures satellites maintain orbit around Earth or other planets. Interplanetary Missions: The second cosmic velocity is vital for spacecraft to escape Earth's gravitational pull and travel to other planets. Potential Interstellar Travel: Achieving escape velocities high enough to leave a planetary system (third cosmic velocity) is a significant challenge for interstellar missions.","title":"Calculations for Different Celestial Bodies"},{"location":"Physics/2%20Gravity/P2/Escape%20Velocities%20and%20Cosmic%20Velocities/#visualization","text":"Visualizing these velocities involves depicting the trajectory of objects as they achieve these critical speeds: Orbiting Satellites: For Earth orbit, objects follow curved paths around the planet. Escape Trajectories: Objects leaving planetary systems follow hyperbolic trajectories, escaping the gravitational influence.","title":"Visualization"},{"location":"Physics/2%20Gravity/P2/Implementation/","text":"","title":"Implementation"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/","text":"Background In analyzing the possible trajectories of a payload released near Earth, we must consider the shape of the path determined by its initial conditions, primarily velocity and altitude. Trajectories can generally be categorized into three types: elliptical, parabolic, and hyperbolic. Here's how these trajectories relate to orbital insertion, reentry, and escape scenarios, along with a conceptual framework for numerical analysis. Types of Trajectories Elliptical Trajectory Description: An elliptical trajectory implies an orbit where the gravitational force of the Earth acts as the centripetal force keeping the payload in a closed orbit. An ellipse includes circular orbits as a special case where the eccentricity is zero. Scenario: If the payload is released with a velocity below escape velocity \\(<v_2\\) but above orbital velocity \\(v_1\\) , it will enter an elliptical orbit. Use in Space Exploration: This is desirable for satellites that need to orbit Earth or other celestial bodies. Parabolic Trajectory Description: A parabolic trajectory indicates that the payload is on the threshold of escape, having just enough energy to break free from Earth's gravity, but not more. Scenario: Occurs at exactly the escape velocity \\(v_2\\) . This is a theoretical construct as maintaining exactly parabolic conditions is practically challenging. Use in Space Exploration: Useful for trajectory analysis; practically rare due to precise conditions needed. Hyperbolic Trajectory Description: In a hyperbolic trajectory, the payload has excess energy compared to the parabolic trajectory, indicating that it will escape Earth\u2019s gravitational field. Scenario: When the payload's velocity exceeds escape velocity \\(>v_2\\) . Use in Space Exploration: Required for missions aiming to leave Earth permanently, for interplanetary and interstellar missions. Numerical Analysis of Trajectories To perform a numerical analysis of a payload's trajectory, we\u2019ll use Newton's laws of motion and gravitational forces. The following steps outline the numerical computation process: Initial Conditions: Position: Initial altitude above Earth. Velocity: Initial speed and direction of the payload. Mathematical Model Use a differential equation based on Newton's second law of motion and gravitational attraction: \\[ \\mathbf{F} = m \\cdot \\mathbf{a} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\(m\\) is the mass of the payload \\(G\\) is the gravitational constant \\(M\\) is the mass of Earth \\(r\\) is the distance between the Earth's center and the payload \\(\\hat{r}\\) is the unit vector along the radial direction. Numerical Integration Apply numerical methods like Euler's method or the Runge-Kutta method to solve the differential equations iteratively over small time steps. Simulation Plot the position and velocity vectors as functions of time to observe the trajectory path. Trajectory Analysis and Scenarios Orbital Insertion: Achieving the precise initial velocity for an elliptical orbit allows the payload to enter orbit, essential for satellite deployments. Reentry: If the trajectory remains elliptical but intersects Earth's atmosphere, the payload will re-enter, suitable for returning spacecraft or decommissioning satellites. Escape Trajectory: Exceeding escape velocity leads to a hyperbolic path, ensuring the payload leaves Earth's gravitational influence, a key for missions beyond Earth. Conclusion Understanding and calculating these trajectories provides crucial knowledge for mission design, satellite operations, reentry planning, and interplanetary travel. Numerical simulations assist in mission planning by predicting how varying initial conditions affect the path and outcome, allowing for optimized launch and mission trajectories based on specific objectives.","title":"Background"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#background","text":"In analyzing the possible trajectories of a payload released near Earth, we must consider the shape of the path determined by its initial conditions, primarily velocity and altitude. Trajectories can generally be categorized into three types: elliptical, parabolic, and hyperbolic. Here's how these trajectories relate to orbital insertion, reentry, and escape scenarios, along with a conceptual framework for numerical analysis. Types of Trajectories","title":"Background"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#elliptical-trajectory","text":"Description: An elliptical trajectory implies an orbit where the gravitational force of the Earth acts as the centripetal force keeping the payload in a closed orbit. An ellipse includes circular orbits as a special case where the eccentricity is zero. Scenario: If the payload is released with a velocity below escape velocity \\(<v_2\\) but above orbital velocity \\(v_1\\) , it will enter an elliptical orbit. Use in Space Exploration: This is desirable for satellites that need to orbit Earth or other celestial bodies.","title":"Elliptical Trajectory"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#parabolic-trajectory","text":"Description: A parabolic trajectory indicates that the payload is on the threshold of escape, having just enough energy to break free from Earth's gravity, but not more. Scenario: Occurs at exactly the escape velocity \\(v_2\\) . This is a theoretical construct as maintaining exactly parabolic conditions is practically challenging. Use in Space Exploration: Useful for trajectory analysis; practically rare due to precise conditions needed.","title":"Parabolic Trajectory"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#hyperbolic-trajectory","text":"Description: In a hyperbolic trajectory, the payload has excess energy compared to the parabolic trajectory, indicating that it will escape Earth\u2019s gravitational field. Scenario: When the payload's velocity exceeds escape velocity \\(>v_2\\) . Use in Space Exploration: Required for missions aiming to leave Earth permanently, for interplanetary and interstellar missions.","title":"Hyperbolic Trajectory"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#numerical-analysis-of-trajectories","text":"To perform a numerical analysis of a payload's trajectory, we\u2019ll use Newton's laws of motion and gravitational forces. The following steps outline the numerical computation process: Initial Conditions: Position: Initial altitude above Earth. Velocity: Initial speed and direction of the payload.","title":"Numerical Analysis of Trajectories"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#mathematical-model","text":"Use a differential equation based on Newton's second law of motion and gravitational attraction: \\[ \\mathbf{F} = m \\cdot \\mathbf{a} = -\\frac{GMm}{r^2} \\hat{r} \\] Where: \\(m\\) is the mass of the payload \\(G\\) is the gravitational constant \\(M\\) is the mass of Earth \\(r\\) is the distance between the Earth's center and the payload \\(\\hat{r}\\) is the unit vector along the radial direction.","title":"Mathematical Model"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#numerical-integration","text":"Apply numerical methods like Euler's method or the Runge-Kutta method to solve the differential equations iteratively over small time steps.","title":"Numerical Integration"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#simulation","text":"Plot the position and velocity vectors as functions of time to observe the trajectory path. Trajectory Analysis and Scenarios Orbital Insertion: Achieving the precise initial velocity for an elliptical orbit allows the payload to enter orbit, essential for satellite deployments. Reentry: If the trajectory remains elliptical but intersects Earth's atmosphere, the payload will re-enter, suitable for returning spacecraft or decommissioning satellites. Escape Trajectory: Exceeding escape velocity leads to a hyperbolic path, ensuring the payload leaves Earth's gravitational influence, a key for missions beyond Earth.","title":"Simulation"},{"location":"Physics/2%20Gravity/P3/P3%20Trajectories%20of%20a%20Freely%20Released%20Payload%20Near%20Earth/#conclusion","text":"Understanding and calculating these trajectories provides crucial knowledge for mission design, satellite operations, reentry planning, and interplanetary travel. Numerical simulations assist in mission planning by predicting how varying initial conditions affect the path and outcome, allowing for optimized launch and mission trajectories based on specific objectives.","title":"Conclusion"},{"location":"Physics/3%20Waves/Waves/","text":"Analysis of Wave Interference Patterns Formed by Point Sources Wave Equations Assuming a simple harmonic wave emitted from each source with the same frequency and amplitude, the wave equation from a point source located at position \\(x_0, y_0\\) can be described by: \\[ \\psi(x, y, t) = A \\cos(kr - \\omega t + \\phi) \\] where: \\(\\psi\\) is the wave displacement \\(A\\) is the amplitude \\(k\\) is the wave number, given by \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) is the angular frequency, given by \\(\\omega = 2\\pi f\\) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\(x, y\\) \\(\\phi\\) is the phase constant \\(\\lambda\\) is the wavelength \\(f\\) is the frequency Superposition of Waves The principle of superposition states that the resultant wave displacement at any point on the water surface is the sum of the displacements due to each individual wave. Therefore, the total wave displacement \\(\\Psi(x, y, t)\\) is given by (initial 4 vertices): \\[ \\Psi(x, y, t) = \\psi_A(x, y, t) + \\psi_B(x, y, t) + \\psi_C(x, y, t) + \\psi_D(x, y, t) \\] This equation represents the interference pattern on the water surface. Interference Patterns Constructive Interference: Occurs at points where the path difference between waves from two or more sources is an integer multiple of the wavelength \\(m\\lambda\\) , where \\(m\\) is an integer. At these points, the waves reinforce each other, resulting in larger amplitudes. Destructive Interference: Occurs at points where the path difference is an odd multiple of half wavelengths \\((m + \\frac{1}{2})\\lambda\\) . Here, the waves cancel each other, resulting in nodes or points of no displacement. Combined Displacement Function The resultant wave displacement at a point ((x, y)) at time (t) is given by: \\[ \\Psi(x, y, t) = \\psi_A(x, y, t) + \\psi_B(x, y, t) + \\psi_C(x, y, t) + \\psi_D(x, y, t) \\] where each \\(\\psi\\) is the wave equation from an individual source. Simulation on Waves import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Slider # Parameters L = 4.0 # Side length of the square c = 0.5 # Wave speed f = 0.5 # Frequency of the wave A = 0.5 # Amplitude of the wave lambda_ = 0.5 # Wavelength k = 2 * np.pi / lambda_ # Wave number t = 0.3 # Time # Function to calculate the wave displacement from a source def wave_displacement(x, y, x0, y0, k, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A * np.sin(2 * np.pi * f * t - k * r)) # Function to calculate and plot the interference pattern def plot_interference(num_sources): fig, ax = plt.subplots() plt.subplots_adjust(left=0.15, bottom=0.15, right=0.85, top=0.85, wspace=0.2, hspace=0.2) ax.set_title('Interference Pattern of Waves') # Preparing the grid x = np.linspace(-L, L, 1200) y = np.linspace(-L, L, 1200) X, Y = np.meshgrid(x, y) # Create a regular polygon (circle-like distribution) for more sources angles = np.linspace(0, 3 * np.pi, num_sources, endpoint=False) positions = [(L * np.cos(angle), L * np.sin(angle)) for angle in angles] # Calculate superposition Z = np.zeros(X.shape) for (x0, y0) in positions: Z += wave_displacement(X, Y, x0, y0, k, t) # Find min and max values for consistent color scale vmin = np.min(Z) vmax = np.max(Z) # Plot contour = ax.contourf(X, Y, Z, 20, cmap='RdBu_r', vmin=vmin, vmax=vmax) # Set vmin and vmax here cbar = plt.colorbar(contour) # Add the sources to the plot for x0, y0 in positions: ax.plot(x0, y0, 'X', markersize=6, color='yellow') axcolor = 'lightgoldenrodyellow' axSources1 = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor) #axSources2 = plt.axes([0.15, 0.1, 0.65, 0.03], facecolor=axcolor) sliderSources1 = Slider(axSources1, 'Num Sources', 1, 75, valinit=num_sources, valstep=1) #sliderSources2 = Slider(axSources2, 'Graph size', 1, 4, valinit=L, valstep=0.25) def update(val): num_sources = int(sliderSources1.val) # xL = float(sliderSources2.val) xL = L angles = np.linspace(0, xL * np.pi, num_sources, endpoint=False) positions = [(xL * np.cos(angle), xL * np.sin(angle)) for angle in angles] Z = np.zeros(X.shape) for (x0, y0) in positions: Z += wave_displacement(X, Y, x0 , y0, k, t) # Plot with fixed color limits ax.clear() contour = ax.contourf(X, Y, Z, 20, cmap='RdBu_r', vmin=vmin, vmax=vmax) # Set vmin and vmax here cbar = plt.colorbar(contour, ax=ax) # Add the sources to the plot for x0, y0 in positions: ax.plot(x0, y0, 'x', markersize=6, color='yellow') cbar.remove() plt.draw() sliderSources1.on_changed(update) # sliderSources2.on_changed(update) plt.show() # Initial call to plot the interference pattern plot_interference(4) Waves Simulations - Using balls/objects on a string Waves Simulations - Surface disturbance One Source Four Sources Six Sources Eight Sources Ten Sources Thirteen Sources Twenty Seven Sources Fourty Sources Fifty Sources GIF animation cycling thru the number of sources","title":"Analysis of Wave Interference Patterns Formed by Point Sources"},{"location":"Physics/3%20Waves/Waves/#analysis-of-wave-interference-patterns-formed-by-point-sources","text":"","title":"Analysis of Wave Interference Patterns Formed by Point Sources"},{"location":"Physics/3%20Waves/Waves/#wave-equations","text":"Assuming a simple harmonic wave emitted from each source with the same frequency and amplitude, the wave equation from a point source located at position \\(x_0, y_0\\) can be described by: \\[ \\psi(x, y, t) = A \\cos(kr - \\omega t + \\phi) \\] where: \\(\\psi\\) is the wave displacement \\(A\\) is the amplitude \\(k\\) is the wave number, given by \\(k = \\frac{2\\pi}{\\lambda}\\) \\(\\omega\\) is the angular frequency, given by \\(\\omega = 2\\pi f\\) \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\(x, y\\) \\(\\phi\\) is the phase constant \\(\\lambda\\) is the wavelength \\(f\\) is the frequency","title":"Wave Equations"},{"location":"Physics/3%20Waves/Waves/#superposition-of-waves","text":"The principle of superposition states that the resultant wave displacement at any point on the water surface is the sum of the displacements due to each individual wave. Therefore, the total wave displacement \\(\\Psi(x, y, t)\\) is given by (initial 4 vertices): \\[ \\Psi(x, y, t) = \\psi_A(x, y, t) + \\psi_B(x, y, t) + \\psi_C(x, y, t) + \\psi_D(x, y, t) \\] This equation represents the interference pattern on the water surface.","title":"Superposition of Waves"},{"location":"Physics/3%20Waves/Waves/#interference-patterns","text":"Constructive Interference: Occurs at points where the path difference between waves from two or more sources is an integer multiple of the wavelength \\(m\\lambda\\) , where \\(m\\) is an integer. At these points, the waves reinforce each other, resulting in larger amplitudes. Destructive Interference: Occurs at points where the path difference is an odd multiple of half wavelengths \\((m + \\frac{1}{2})\\lambda\\) . Here, the waves cancel each other, resulting in nodes or points of no displacement.","title":"Interference Patterns"},{"location":"Physics/3%20Waves/Waves/#combined-displacement-function","text":"The resultant wave displacement at a point ((x, y)) at time (t) is given by: \\[ \\Psi(x, y, t) = \\psi_A(x, y, t) + \\psi_B(x, y, t) + \\psi_C(x, y, t) + \\psi_D(x, y, t) \\] where each \\(\\psi\\) is the wave equation from an individual source.","title":"Combined Displacement Function"},{"location":"Physics/3%20Waves/Waves/#simulation-on-waves","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib.widgets import Slider # Parameters L = 4.0 # Side length of the square c = 0.5 # Wave speed f = 0.5 # Frequency of the wave A = 0.5 # Amplitude of the wave lambda_ = 0.5 # Wavelength k = 2 * np.pi / lambda_ # Wave number t = 0.3 # Time # Function to calculate the wave displacement from a source def wave_displacement(x, y, x0, y0, k, t): r = np.sqrt((x - x0)**2 + (y - y0)**2) return (A * np.sin(2 * np.pi * f * t - k * r)) # Function to calculate and plot the interference pattern def plot_interference(num_sources): fig, ax = plt.subplots() plt.subplots_adjust(left=0.15, bottom=0.15, right=0.85, top=0.85, wspace=0.2, hspace=0.2) ax.set_title('Interference Pattern of Waves') # Preparing the grid x = np.linspace(-L, L, 1200) y = np.linspace(-L, L, 1200) X, Y = np.meshgrid(x, y) # Create a regular polygon (circle-like distribution) for more sources angles = np.linspace(0, 3 * np.pi, num_sources, endpoint=False) positions = [(L * np.cos(angle), L * np.sin(angle)) for angle in angles] # Calculate superposition Z = np.zeros(X.shape) for (x0, y0) in positions: Z += wave_displacement(X, Y, x0, y0, k, t) # Find min and max values for consistent color scale vmin = np.min(Z) vmax = np.max(Z) # Plot contour = ax.contourf(X, Y, Z, 20, cmap='RdBu_r', vmin=vmin, vmax=vmax) # Set vmin and vmax here cbar = plt.colorbar(contour) # Add the sources to the plot for x0, y0 in positions: ax.plot(x0, y0, 'X', markersize=6, color='yellow') axcolor = 'lightgoldenrodyellow' axSources1 = plt.axes([0.25, 0.1, 0.65, 0.03], facecolor=axcolor) #axSources2 = plt.axes([0.15, 0.1, 0.65, 0.03], facecolor=axcolor) sliderSources1 = Slider(axSources1, 'Num Sources', 1, 75, valinit=num_sources, valstep=1) #sliderSources2 = Slider(axSources2, 'Graph size', 1, 4, valinit=L, valstep=0.25) def update(val): num_sources = int(sliderSources1.val) # xL = float(sliderSources2.val) xL = L angles = np.linspace(0, xL * np.pi, num_sources, endpoint=False) positions = [(xL * np.cos(angle), xL * np.sin(angle)) for angle in angles] Z = np.zeros(X.shape) for (x0, y0) in positions: Z += wave_displacement(X, Y, x0 , y0, k, t) # Plot with fixed color limits ax.clear() contour = ax.contourf(X, Y, Z, 20, cmap='RdBu_r', vmin=vmin, vmax=vmax) # Set vmin and vmax here cbar = plt.colorbar(contour, ax=ax) # Add the sources to the plot for x0, y0 in positions: ax.plot(x0, y0, 'x', markersize=6, color='yellow') cbar.remove() plt.draw() sliderSources1.on_changed(update) # sliderSources2.on_changed(update) plt.show() # Initial call to plot the interference pattern plot_interference(4)","title":"Simulation on Waves"},{"location":"Physics/3%20Waves/Waves/#waves-simulations-using-ballsobjects-on-a-string","text":"","title":"Waves Simulations - Using balls/objects on a string"},{"location":"Physics/3%20Waves/Waves/#waves-simulations-surface-disturbance","text":"","title":"Waves Simulations - Surface disturbance"},{"location":"Physics/3%20Waves/Waves/#one-source","text":"","title":"One Source"},{"location":"Physics/3%20Waves/Waves/#four-sources","text":"","title":"Four Sources"},{"location":"Physics/3%20Waves/Waves/#six-sources","text":"","title":"Six Sources"},{"location":"Physics/3%20Waves/Waves/#eight-sources","text":"","title":"Eight Sources"},{"location":"Physics/3%20Waves/Waves/#ten-sources","text":"","title":"Ten Sources"},{"location":"Physics/3%20Waves/Waves/#thirteen-sources","text":"","title":"Thirteen Sources"},{"location":"Physics/3%20Waves/Waves/#twenty-seven-sources","text":"","title":"Twenty Seven Sources"},{"location":"Physics/3%20Waves/Waves/#fourty-sources","text":"","title":"Fourty Sources"},{"location":"Physics/3%20Waves/Waves/#fifty-sources","text":"","title":"Fifty Sources"},{"location":"Physics/3%20Waves/Waves/#gif-animation-cycling-thru-the-number-of-sources","text":"","title":"GIF animation cycling thru the number of sources"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/","text":"Electromagnetism Electromagnetism is a fundamental branch of physics that deals with the study of electric and magnetic fields and their interactions with matter, particularly charged particles. Below is a detailed analysis covering various aspects, including applications, simulations, and parameter explorations: Applications of Electromagnetism and the Lorentz Force Lorentz Force in Systems Particle Accelerators Particle accelerators use electromagnetic fields to accelerate charged particles to high speeds and contain them within a well-defined path. The Lorentz force is crucial in bending and focusing the particle beams using magnetic fields. Circular motion simulation of a charged particle under a magnetic field into a 3D visualization To further illustrate a helical path of a charged particle in a magnetic field, we can simulate its motion when the initial velocity has components both parallel and perpendicular to the magnetic field direction. This example will focus solely on the helical trajectory caused by a magnetic field. Here is a Python script that demonstrates this motion using 3D visualization Mass Spectrometers Mass spectrometers use the Lorentz force to separate ions based on their mass-to-charge ratio. When ions pass through magnetic and/or electric fields, they are deflected, allowing their trajectories to be analyzed for identification. Plasma Confinement In devices like tokamaks used in nuclear fusion research, magnetic fields are employed to confine plasma, relying on the Lorentz force to maintain stability and control the motion of charged particles within the plasma. Control of Charged Particles Electric Fields \\(E\\) : Electric fields exert a force on charged particles, changing their velocity linearly in the direction of the field. This is particularly useful in accelerating particles or deflecting them in devices like cathode ray tubes. Magnetic Fields \\(B\\) : Magnetic fields exert a perpendicular force on moving charged particles, affecting their trajectory without changing their speed. This causes particles to move in circular or helical paths. Simulating Particle Motion To simulate the trajectory of a charged particle under different field configurations, we can consider: Uniform Magnetic Field A charged particle moving perpendicular to a uniform magnetic field will undergo circular motion due to the centripetal force provided by the Lorentz force. The radius of the circle $ r $ can be determined by the equation: \\(r = \\frac{mv}{qB}\\) , where \\(m\\) is the mass, \\(v\\) is the velocity, \\(q\\) is the charge, and \\(B\\) is the magnetic field strength. Combined Uniform Electric and Magnetic Fields When both fields are present, particles experience both linear acceleration (from the electric field) and circular motion or drift motion (from the magnetic field). Depending on the orientation and magnitudes, particles may exhibit helical motion or drift in the direction perpendicular to both fields. Crossed Electric and Magnetic Fields When electric and magnetic fields are perpendicular, one can observe phenomena like the Hall effect, where particles drift due to the combined effect of \\(\\overrightarrow{E}\\) and \\(\\overrightarrow{B}\\) .","title":"Electromagnetism"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#electromagnetism","text":"Electromagnetism is a fundamental branch of physics that deals with the study of electric and magnetic fields and their interactions with matter, particularly charged particles. Below is a detailed analysis covering various aspects, including applications, simulations, and parameter explorations:","title":"Electromagnetism"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#applications-of-electromagnetism-and-the-lorentz-force","text":"","title":"Applications of Electromagnetism and the Lorentz Force"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#lorentz-force-in-systems","text":"","title":"Lorentz Force in Systems"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#particle-accelerators","text":"Particle accelerators use electromagnetic fields to accelerate charged particles to high speeds and contain them within a well-defined path. The Lorentz force is crucial in bending and focusing the particle beams using magnetic fields.","title":"Particle Accelerators"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#circular-motion-simulation-of-a-charged-particle-under-a-magnetic-field-into-a-3d-visualization","text":"To further illustrate a helical path of a charged particle in a magnetic field, we can simulate its motion when the initial velocity has components both parallel and perpendicular to the magnetic field direction. This example will focus solely on the helical trajectory caused by a magnetic field. Here is a Python script that demonstrates this motion using 3D visualization","title":"Circular motion simulation of a charged particle under a magnetic field into a 3D visualization"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#mass-spectrometers","text":"Mass spectrometers use the Lorentz force to separate ions based on their mass-to-charge ratio. When ions pass through magnetic and/or electric fields, they are deflected, allowing their trajectories to be analyzed for identification.","title":"Mass Spectrometers"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#plasma-confinement","text":"In devices like tokamaks used in nuclear fusion research, magnetic fields are employed to confine plasma, relying on the Lorentz force to maintain stability and control the motion of charged particles within the plasma.","title":"Plasma Confinement"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#control-of-charged-particles","text":"Electric Fields \\(E\\) : Electric fields exert a force on charged particles, changing their velocity linearly in the direction of the field. This is particularly useful in accelerating particles or deflecting them in devices like cathode ray tubes. Magnetic Fields \\(B\\) : Magnetic fields exert a perpendicular force on moving charged particles, affecting their trajectory without changing their speed. This causes particles to move in circular or helical paths. Simulating Particle Motion To simulate the trajectory of a charged particle under different field configurations, we can consider:","title":"Control of Charged Particles"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#uniform-magnetic-field","text":"A charged particle moving perpendicular to a uniform magnetic field will undergo circular motion due to the centripetal force provided by the Lorentz force. The radius of the circle $ r $ can be determined by the equation: \\(r = \\frac{mv}{qB}\\) , where \\(m\\) is the mass, \\(v\\) is the velocity, \\(q\\) is the charge, and \\(B\\) is the magnetic field strength.","title":"Uniform Magnetic Field"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#combined-uniform-electric-and-magnetic-fields","text":"When both fields are present, particles experience both linear acceleration (from the electric field) and circular motion or drift motion (from the magnetic field). Depending on the orientation and magnitudes, particles may exhibit helical motion or drift in the direction perpendicular to both fields.","title":"Combined Uniform Electric and Magnetic Fields"},{"location":"Physics/4%20Electromagnetism/Electromagnetism/#crossed-electric-and-magnetic-fields","text":"When electric and magnetic fields are perpendicular, one can observe phenomena like the Hall effect, where particles drift due to the combined effect of \\(\\overrightarrow{E}\\) and \\(\\overrightarrow{B}\\) .","title":"Crossed Electric and Magnetic Fields"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/","text":"List of Codes Figure 1 - Circular Motion of a Charged Particle in a Magnetic Field This code simulates the circular motion of a charged particle in a uniform magnetic field. The particle's trajectory is plotted in the x-y plane, showing the circular path it takes due to the Lorentz force. import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity of the particle (m/s) time = np.linspace(0, 1e-7, 1000) # Time array # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion x = r * np.cos(omega * time) y = r * np.sin(omega * time) # Create the plot plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Particle trajectory') plt.scatter([0], [0], color='r', label='Center of motion', zorder=5) plt.axhline(0, color='k', linestyle='--', linewidth=0.8) plt.axvline(0, color='k', linestyle='--', linewidth=0.8) plt.title('Circular Motion of a Charged Particle in a Magnetic Field') plt.xlabel('x-position (m)') plt.ylabel('y-position (m)') plt.grid(True) plt.legend() plt.gca().set_aspect('equal', adjustable='box') plt.show() Figure 2 - Circular Motion of a Charged Particle in a Magnetic Field (3D) This code simulates the circular motion of a charged particle in a uniform magnetic field in 3D space. The trajectory is plotted in 3D, with time represented along the z-axis. The particle moves in a circular path in the x-y plane, while the z-coordinate increases linearly with time. This represents the particle's motion through time, showing how it moves in a helical path in 3D space. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity of the particle (m/s) t_max = 1e-7 # Simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion in 3D x = r * np.cos(omega * time) y = r * np.sin(omega * time) z = time # Representing time along the z-axis # Create the 3D plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label='Particle trajectory') ax.set_title('Circular Motion of a Charged Particle in a Magnetic Field (3D)') ax.set_xlabel('x-position (m)') ax.set_ylabel('y-position (m)') ax.set_zlabel('Time (s)') ax.scatter([0], [0], [0], color='r', label='Center of motion', zorder=5) # Center point plt.legend() plt.show() Figure 3 - Helical Motion of a Charged Particle in Crossed E and B Fields This script simulates the helical motion of a charged particle in crossed electric and magnetic fields. The particle is subjected to a constant electric field in the x-direction and a constant magnetic field in the z-direction. The motion is calculated using the Lorentz force law, and the trajectory is plotted in 3D. The simulation parameters can be adjusted to observe different behaviors of the particle. The code uses numpy for numerical calculations and matplotlib for plotting. The trajectory is visualized in a 3D plot, showing the helical path of the particle as it moves through the fields. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) E = 1e3 # Electric field strength (V/m) v0 = 2e6 # Initial velocity of the particle (m/s) t_max = 1e-7 # Maximum time for the simulation (s) num_points = 1000 # Number of points in the simulation # Time discretization time = np.linspace(0, t_max, num_points) # Initialize position and velocity arrays position = np.zeros((num_points, 3)) velocity = np.zeros((num_points, 3)) # Initial conditions velocity[0] = [v0, 0, 0] # Initial velocity in x-direction # Time increment dt = t_max / num_points # Main loop to calculate position and velocity for i in range(1, num_points): v = velocity[i-1] F_electric = q * np.array([E, 0, 0]) # Electric force F_magnetic = q * np.cross(v, [0, 0, B]) # Magnetic force F_total = F_electric + F_magnetic a = F_total / m # Acceleration # Update velocity and position velocity[i] = velocity[i-1] + a * dt position[i] = position[i-1] + velocity[i] * dt # Plotting the results fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(position[:, 0], position[:, 1], position[:, 2], label='Particle trajectory') ax.set_title('Helical Motion of a Charged Particle in Crossed E and B Fields') ax.set_xlabel('x-position (m)') ax.set_ylabel('y-position (m)') ax.set_zlabel('z-position (m)') plt.legend() plt.show() Figure 4 - Mass Spectrometer: Ion Trajectories Based on Mass-to-Charge Ratio This code simulates the trajectories of ions in a mass spectrometer based on their mass-to-charge ratios. It uses the Lorentz force law to calculate the motion of ions in electric and magnetic fields. The code generates a plot showing the trajectories of three different ions with varying mass-to-charge ratios. The plot illustrates how the radius of curvature of the ion paths depends on their mass-to-charge ratios. The ions are accelerated by an electric field and then deflected by a magnetic field, creating circular paths. The code uses NumPy for numerical calculations and Matplotlib for plotting the trajectories. import numpy as np import matplotlib.pyplot as plt # Constants E = 1e5 # Electric field strength (V/m) B = 1.0 # Magnetic field strength (T) d = 0.1 # Distance over which the electric field accelerates the ions (m) v0 = np.sqrt(2 * E * 1.6e-19 / 1.67e-27) # Initial velocity for reference ion with m/q = 1 # Mass-to-charge ratios for three different ions m_q_ratios = [1, 2, 0.5] # m/q relative to the reference ion colors = ['r', 'g', 'b'] labels = ['m/q = 1', 'm/q = 2', 'm/q = 0.5'] # Time array time = np.linspace(0, 1e-5, 1000) # Create the plot plt.figure(figsize=(12, 6)) for m_q, color, label in zip(m_q_ratios, colors, labels): # Calculate the velocity based on m/q ratio v = v0 / np.sqrt(m_q) # Radius of the trajectory radius = v / (B * 1.6e-19 / (m_q * 1.67e-27)) # Calculate trajectory x = radius * np.sin(v * B * time / (m_q * 1.67e-27)) y = radius * np.cos(v * B * time / (m_q * 1.67e-27)) - radius plt.plot(x, y, color=color, label=label) plt.title('Mass Spectrometer: Ion Trajectories Based on Mass-to-Charge Ratio') plt.xlabel('x-position (m)') plt.ylabel('y-position (m)') plt.axhline(0, color='k', linestyle='--', linewidth=0.8) plt.legend() plt.grid(True) plt.show() Figure 5 - 3D Representation of Plasma Confinement in a Toroidal Field This code generates a 3D plot of a toroidal magnetic field, representing plasma confinement in fusion reactors. The plot includes a toroidal surface and magnetic field lines to illustrate the concept of plasma confinement. The code uses NumPy for numerical calculations and Matplotlib for plotting. The toroidal field is a common configuration in fusion reactors, such as tokamaks, where plasma is confined in a donut-shaped magnetic field. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters for toroidal field radius_major = 1.0 # Major radius of the torus (distance from center of tube to center of torus) radius_minor = 0.2 # Minor radius of the torus (radius of the tube) # Create data for a torus theta = np.linspace(0, 2 * np.pi, 100) # Angle around the torus phi = np.linspace(0, 2 * np.pi, 100) # Angle along the torus' tube theta, phi = np.meshgrid(theta, phi) # Parametric equations for the torus x = (radius_major + radius_minor * np.cos(phi)) * np.cos(theta) y = (radius_major + radius_minor * np.cos(phi)) * np.sin(theta) z = radius_minor * np.sin(phi) # Create the plot fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the torus surface ax.plot_surface(x, y, z, color='c', alpha=0.5, rstride=5, cstride=5, edgecolor='none') # Plot magnetic field lines num_lines = 8 for i in range(num_lines): angle_offset = (i / num_lines) * 2 * np.pi x_line = (radius_major + radius_minor * np.cos(phi)) * np.cos(theta + angle_offset) y_line = (radius_major + radius_minor * np.cos(phi)) * np.sin(theta + angle_offset) z_line = radius_minor * np.sin(phi) ax.plot(x_line[0, :], y_line[0, :], z_line[0, :], color='r') # Set labels and title ax.set_title('3D Representation of Plasma Confinement in a Toroidal Field') ax.set_xlabel('X Axis') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis') ax.view_init(elev=30, azim=60) # Better viewing angle plt.show() Figure 6 - Circular Motion in a Uniform Magnetic Field This script simulates the motion of a charged particle in a uniform magnetic field. The particle moves in a circular path due to the Lorentz force acting on it. The simulation visualizes the trajectory of the particle and the magnetic field lines. The code uses NumPy for numerical calculations and Matplotlib for plotting. The 3D plot shows the circular motion of the particle and the magnetic field lines. The particle is assumed to have a charge of 1.6e-19 C and a mass of 9.11e-31 kg. The magnetic field strength is set to 1.0 Tesla, and the initial velocity of the particle is 1e6 m/s. The simulation runs for a maximum time of 1e-7 seconds with 1000 points in the time array. The radius of the circular motion and the angular frequency are calculated based on the charge, mass, and magnetic field strength. The parametric equations for circular motion are used to calculate the x and y coordinates of the particle's trajectory. The z coordinate is set to zero, indicating no motion in the z-direction. The 3D plot is created using Matplotlib's Axes3D module, and the trajectory of the particle is plotted in blue. The center of motion is marked with a red dot, and several magnetic field lines are plotted in green. The plot is labeled with appropriate titles and axis labels, and the viewing angle is adjusted for better visualization. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity magnitude of the particle (m/s) t_max = 1e-7 # Maximum simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion x = r * np.cos(omega * time) y = r * np.sin(omega * time) z = np.zeros_like(time) # No motion in the z-direction # Create the 3D plot fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the circular motion ax.plot(x, y, z, label='Particle trajectory', color='b') ax.scatter([0], [0], [0], color='r', label='Center of motion', zorder=5) # Plot some magnetic field lines bz = np.linspace(-1, 1, num_points) bx = np.zeros_like(bz) + r # Offset field lines by = np.zeros_like(bz) for bx_offset in np.linspace(-r, r, 5): ax.plot(bx + bx_offset, by, bz, color='g', alpha=0.3) # Set labels and title ax.set_title('Circular Motion in a Uniform Magnetic Field') ax.set_xlabel('X Axis') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis (Field Direction)') ax.view_init(elev=25, azim=45) # Adjust viewing angle ax.legend() plt.show() Figure 7 - Particle in Electric and Magnetic Fields This code simulates the motion of a charged particle in a uniform electric field and a uniform magnetic field. The particle experiences a Lorentz force due to the electric and magnetic fields, and its trajectory is plotted in 3D. The simulation uses numerical integration to update the particle's position and velocity over time. The electric field is assumed to be in the x-direction, while the magnetic field is in the z-direction. The initial velocity of the particle is set to zero for simplicity, but can be modified as needed. The simulation parameters can be adjusted to explore different scenarios, such as varying the strength of the fields or the mass of the particle. The resulting plot shows the trajectory of the particle in 3D space, illustrating the combined effects of the electric and magnetic fields on its motion. The code uses NumPy for numerical calculations and Matplotlib for plotting the trajectory. The trajectory is visualized in a 3D plot, with the x-axis representing the electric field direction, the y-axis as a free axis, and the z-axis representing the magnetic field direction. The plot includes labels for the axes and a legend indicating the particle's trajectory. The viewing angle of the plot is adjusted for better visualization. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) E = 1e5 # Electric field magnitude (V/m) B = 1.0 # Magnetic field strength (T) v0 = 0 # Initial velocity (m/s), assume starting from rest for simplicity t_max = 1e-6 # Maximum simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Initial velocity and acceleration v_initial = np.array([v0, 0, 0]) # Start with some initial velocity a_electric = np.array([q * E / m, 0, 0]) # Acceleration due to electric field # Magnetic field direction B_field = np.array([0, 0, B]) # Initialize arrays for position and velocity position = np.zeros((num_points, 3)) velocity = np.zeros((num_points, 3)) velocity[0] = v_initial # Numerical integration dt = t_max / num_points for i in range(1, num_points): v = velocity[i-1] F_magnetic = q * np.cross(v, B_field) # Lorentz force component due to magnetic field a_magnetic = F_magnetic / m a_total = a_electric + a_magnetic # Total acceleration # Update velocity and position velocity[i] = velocity[i-1] + a_total * dt position[i] = position[i-1] + velocity[i] * dt # Plotting the trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(position[:, 0], position[:, 1], position[:, 2], label='Particle trajectory', color='b') # Set labels and title ax.set_title('Motion in Combined Uniform Electric and Magnetic Fields') ax.set_xlabel('X Axis (Electric Field Direction)') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis (Magnetic Field Direction)') ax.view_init(elev=25, azim=60) # Adjust viewing angle ax.legend() plt.show()","title":"List of Codes"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#list-of-codes","text":"","title":"List of Codes"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-1-circular-motion-of-a-charged-particle-in-a-magnetic-field","text":"This code simulates the circular motion of a charged particle in a uniform magnetic field. The particle's trajectory is plotted in the x-y plane, showing the circular path it takes due to the Lorentz force. import numpy as np import matplotlib.pyplot as plt # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity of the particle (m/s) time = np.linspace(0, 1e-7, 1000) # Time array # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion x = r * np.cos(omega * time) y = r * np.sin(omega * time) # Create the plot plt.figure(figsize=(8, 8)) plt.plot(x, y, label='Particle trajectory') plt.scatter([0], [0], color='r', label='Center of motion', zorder=5) plt.axhline(0, color='k', linestyle='--', linewidth=0.8) plt.axvline(0, color='k', linestyle='--', linewidth=0.8) plt.title('Circular Motion of a Charged Particle in a Magnetic Field') plt.xlabel('x-position (m)') plt.ylabel('y-position (m)') plt.grid(True) plt.legend() plt.gca().set_aspect('equal', adjustable='box') plt.show()","title":"Figure 1 - Circular Motion of a Charged Particle in a Magnetic Field"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-2-circular-motion-of-a-charged-particle-in-a-magnetic-field-3d","text":"This code simulates the circular motion of a charged particle in a uniform magnetic field in 3D space. The trajectory is plotted in 3D, with time represented along the z-axis. The particle moves in a circular path in the x-y plane, while the z-coordinate increases linearly with time. This represents the particle's motion through time, showing how it moves in a helical path in 3D space. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity of the particle (m/s) t_max = 1e-7 # Simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion in 3D x = r * np.cos(omega * time) y = r * np.sin(omega * time) z = time # Representing time along the z-axis # Create the 3D plot fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label='Particle trajectory') ax.set_title('Circular Motion of a Charged Particle in a Magnetic Field (3D)') ax.set_xlabel('x-position (m)') ax.set_ylabel('y-position (m)') ax.set_zlabel('Time (s)') ax.scatter([0], [0], [0], color='r', label='Center of motion', zorder=5) # Center point plt.legend() plt.show()","title":"Figure 2 - Circular Motion of a Charged Particle in a Magnetic Field (3D)"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-3-helical-motion-of-a-charged-particle-in-crossed-e-and-b-fields","text":"This script simulates the helical motion of a charged particle in crossed electric and magnetic fields. The particle is subjected to a constant electric field in the x-direction and a constant magnetic field in the z-direction. The motion is calculated using the Lorentz force law, and the trajectory is plotted in 3D. The simulation parameters can be adjusted to observe different behaviors of the particle. The code uses numpy for numerical calculations and matplotlib for plotting. The trajectory is visualized in a 3D plot, showing the helical path of the particle as it moves through the fields. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) E = 1e3 # Electric field strength (V/m) v0 = 2e6 # Initial velocity of the particle (m/s) t_max = 1e-7 # Maximum time for the simulation (s) num_points = 1000 # Number of points in the simulation # Time discretization time = np.linspace(0, t_max, num_points) # Initialize position and velocity arrays position = np.zeros((num_points, 3)) velocity = np.zeros((num_points, 3)) # Initial conditions velocity[0] = [v0, 0, 0] # Initial velocity in x-direction # Time increment dt = t_max / num_points # Main loop to calculate position and velocity for i in range(1, num_points): v = velocity[i-1] F_electric = q * np.array([E, 0, 0]) # Electric force F_magnetic = q * np.cross(v, [0, 0, B]) # Magnetic force F_total = F_electric + F_magnetic a = F_total / m # Acceleration # Update velocity and position velocity[i] = velocity[i-1] + a * dt position[i] = position[i-1] + velocity[i] * dt # Plotting the results fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(position[:, 0], position[:, 1], position[:, 2], label='Particle trajectory') ax.set_title('Helical Motion of a Charged Particle in Crossed E and B Fields') ax.set_xlabel('x-position (m)') ax.set_ylabel('y-position (m)') ax.set_zlabel('z-position (m)') plt.legend() plt.show()","title":"Figure 3 - Helical Motion of a Charged Particle in Crossed E and B Fields"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-4-mass-spectrometer-ion-trajectories-based-on-mass-to-charge-ratio","text":"This code simulates the trajectories of ions in a mass spectrometer based on their mass-to-charge ratios. It uses the Lorentz force law to calculate the motion of ions in electric and magnetic fields. The code generates a plot showing the trajectories of three different ions with varying mass-to-charge ratios. The plot illustrates how the radius of curvature of the ion paths depends on their mass-to-charge ratios. The ions are accelerated by an electric field and then deflected by a magnetic field, creating circular paths. The code uses NumPy for numerical calculations and Matplotlib for plotting the trajectories. import numpy as np import matplotlib.pyplot as plt # Constants E = 1e5 # Electric field strength (V/m) B = 1.0 # Magnetic field strength (T) d = 0.1 # Distance over which the electric field accelerates the ions (m) v0 = np.sqrt(2 * E * 1.6e-19 / 1.67e-27) # Initial velocity for reference ion with m/q = 1 # Mass-to-charge ratios for three different ions m_q_ratios = [1, 2, 0.5] # m/q relative to the reference ion colors = ['r', 'g', 'b'] labels = ['m/q = 1', 'm/q = 2', 'm/q = 0.5'] # Time array time = np.linspace(0, 1e-5, 1000) # Create the plot plt.figure(figsize=(12, 6)) for m_q, color, label in zip(m_q_ratios, colors, labels): # Calculate the velocity based on m/q ratio v = v0 / np.sqrt(m_q) # Radius of the trajectory radius = v / (B * 1.6e-19 / (m_q * 1.67e-27)) # Calculate trajectory x = radius * np.sin(v * B * time / (m_q * 1.67e-27)) y = radius * np.cos(v * B * time / (m_q * 1.67e-27)) - radius plt.plot(x, y, color=color, label=label) plt.title('Mass Spectrometer: Ion Trajectories Based on Mass-to-Charge Ratio') plt.xlabel('x-position (m)') plt.ylabel('y-position (m)') plt.axhline(0, color='k', linestyle='--', linewidth=0.8) plt.legend() plt.grid(True) plt.show()","title":"Figure 4 - Mass Spectrometer: Ion Trajectories Based on Mass-to-Charge Ratio"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-5-3d-representation-of-plasma-confinement-in-a-toroidal-field","text":"This code generates a 3D plot of a toroidal magnetic field, representing plasma confinement in fusion reactors. The plot includes a toroidal surface and magnetic field lines to illustrate the concept of plasma confinement. The code uses NumPy for numerical calculations and Matplotlib for plotting. The toroidal field is a common configuration in fusion reactors, such as tokamaks, where plasma is confined in a donut-shaped magnetic field. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Parameters for toroidal field radius_major = 1.0 # Major radius of the torus (distance from center of tube to center of torus) radius_minor = 0.2 # Minor radius of the torus (radius of the tube) # Create data for a torus theta = np.linspace(0, 2 * np.pi, 100) # Angle around the torus phi = np.linspace(0, 2 * np.pi, 100) # Angle along the torus' tube theta, phi = np.meshgrid(theta, phi) # Parametric equations for the torus x = (radius_major + radius_minor * np.cos(phi)) * np.cos(theta) y = (radius_major + radius_minor * np.cos(phi)) * np.sin(theta) z = radius_minor * np.sin(phi) # Create the plot fig = plt.figure(figsize=(12, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the torus surface ax.plot_surface(x, y, z, color='c', alpha=0.5, rstride=5, cstride=5, edgecolor='none') # Plot magnetic field lines num_lines = 8 for i in range(num_lines): angle_offset = (i / num_lines) * 2 * np.pi x_line = (radius_major + radius_minor * np.cos(phi)) * np.cos(theta + angle_offset) y_line = (radius_major + radius_minor * np.cos(phi)) * np.sin(theta + angle_offset) z_line = radius_minor * np.sin(phi) ax.plot(x_line[0, :], y_line[0, :], z_line[0, :], color='r') # Set labels and title ax.set_title('3D Representation of Plasma Confinement in a Toroidal Field') ax.set_xlabel('X Axis') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis') ax.view_init(elev=30, azim=60) # Better viewing angle plt.show()","title":"Figure 5 - 3D Representation of Plasma Confinement in a Toroidal Field"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-6-circular-motion-in-a-uniform-magnetic-field","text":"This script simulates the motion of a charged particle in a uniform magnetic field. The particle moves in a circular path due to the Lorentz force acting on it. The simulation visualizes the trajectory of the particle and the magnetic field lines. The code uses NumPy for numerical calculations and Matplotlib for plotting. The 3D plot shows the circular motion of the particle and the magnetic field lines. The particle is assumed to have a charge of 1.6e-19 C and a mass of 9.11e-31 kg. The magnetic field strength is set to 1.0 Tesla, and the initial velocity of the particle is 1e6 m/s. The simulation runs for a maximum time of 1e-7 seconds with 1000 points in the time array. The radius of the circular motion and the angular frequency are calculated based on the charge, mass, and magnetic field strength. The parametric equations for circular motion are used to calculate the x and y coordinates of the particle's trajectory. The z coordinate is set to zero, indicating no motion in the z-direction. The 3D plot is created using Matplotlib's Axes3D module, and the trajectory of the particle is plotted in blue. The center of motion is marked with a red dot, and several magnetic field lines are plotted in green. The plot is labeled with appropriate titles and axis labels, and the viewing angle is adjusted for better visualization. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) B = 1.0 # Magnetic field strength (Tesla) v0 = 1e6 # Initial velocity magnitude of the particle (m/s) t_max = 1e-7 # Maximum simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Calculate the radius and angular frequency r = m * v0 / (q * B) omega = q * B / m # Parametric equations for circular motion x = r * np.cos(omega * time) y = r * np.sin(omega * time) z = np.zeros_like(time) # No motion in the z-direction # Create the 3D plot fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') # Plot the circular motion ax.plot(x, y, z, label='Particle trajectory', color='b') ax.scatter([0], [0], [0], color='r', label='Center of motion', zorder=5) # Plot some magnetic field lines bz = np.linspace(-1, 1, num_points) bx = np.zeros_like(bz) + r # Offset field lines by = np.zeros_like(bz) for bx_offset in np.linspace(-r, r, 5): ax.plot(bx + bx_offset, by, bz, color='g', alpha=0.3) # Set labels and title ax.set_title('Circular Motion in a Uniform Magnetic Field') ax.set_xlabel('X Axis') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis (Field Direction)') ax.view_init(elev=25, azim=45) # Adjust viewing angle ax.legend() plt.show()","title":"Figure 6 - Circular Motion in a Uniform Magnetic Field"},{"location":"Physics/4%20Electromagnetism/ListOfCodes/#figure-7-particle-in-electric-and-magnetic-fields","text":"This code simulates the motion of a charged particle in a uniform electric field and a uniform magnetic field. The particle experiences a Lorentz force due to the electric and magnetic fields, and its trajectory is plotted in 3D. The simulation uses numerical integration to update the particle's position and velocity over time. The electric field is assumed to be in the x-direction, while the magnetic field is in the z-direction. The initial velocity of the particle is set to zero for simplicity, but can be modified as needed. The simulation parameters can be adjusted to explore different scenarios, such as varying the strength of the fields or the mass of the particle. The resulting plot shows the trajectory of the particle in 3D space, illustrating the combined effects of the electric and magnetic fields on its motion. The code uses NumPy for numerical calculations and Matplotlib for plotting the trajectory. The trajectory is visualized in a 3D plot, with the x-axis representing the electric field direction, the y-axis as a free axis, and the z-axis representing the magnetic field direction. The plot includes labels for the axes and a legend indicating the particle's trajectory. The viewing angle of the plot is adjusted for better visualization. import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Constants q = 1.6e-19 # Charge of the particle (Coulombs) m = 9.11e-31 # Mass of the particle (kg) E = 1e5 # Electric field magnitude (V/m) B = 1.0 # Magnetic field strength (T) v0 = 0 # Initial velocity (m/s), assume starting from rest for simplicity t_max = 1e-6 # Maximum simulation time (s) num_points = 1000 # Number of points in the simulation # Time array time = np.linspace(0, t_max, num_points) # Initial velocity and acceleration v_initial = np.array([v0, 0, 0]) # Start with some initial velocity a_electric = np.array([q * E / m, 0, 0]) # Acceleration due to electric field # Magnetic field direction B_field = np.array([0, 0, B]) # Initialize arrays for position and velocity position = np.zeros((num_points, 3)) velocity = np.zeros((num_points, 3)) velocity[0] = v_initial # Numerical integration dt = t_max / num_points for i in range(1, num_points): v = velocity[i-1] F_magnetic = q * np.cross(v, B_field) # Lorentz force component due to magnetic field a_magnetic = F_magnetic / m a_total = a_electric + a_magnetic # Total acceleration # Update velocity and position velocity[i] = velocity[i-1] + a_total * dt position[i] = position[i-1] + velocity[i] * dt # Plotting the trajectory fig = plt.figure(figsize=(10, 8)) ax = fig.add_subplot(111, projection='3d') ax.plot(position[:, 0], position[:, 1], position[:, 2], label='Particle trajectory', color='b') # Set labels and title ax.set_title('Motion in Combined Uniform Electric and Magnetic Fields') ax.set_xlabel('X Axis (Electric Field Direction)') ax.set_ylabel('Y Axis') ax.set_zlabel('Z Axis (Magnetic Field Direction)') ax.view_init(elev=25, azim=60) # Adjust viewing angle ax.legend() plt.show()","title":"Figure 7 - Particle in Electric and Magnetic Fields"},{"location":"Physics/5%20Circuits/Circuits/","text":"Circuits with Graph Theory Graph Representation Model the circuit as a graph where nodes represent junctions and edges represent resistors. Each edge has a weight corresponding to the resistance value. Identifying Series and Parallel Connections: Series Connection Two nodes connected by a single path without splitting (i.e., no intermediate nodes are shared with other paths). Parallel Connection Two nodes connected by multiple independent paths. Reduction Process: Start from a complex graph and iteratively reduce it by replacing series and parallel components with their equivalent resistance. Use recursive traversal for nested combinations. Graph edges with resistance values: A -- B with resistance 5\u03a9 A -- C with resistance 2\u03a9 B -- C with resistance 10\u03a9 B -- E with resistance 4\u03a9 C -- D with resistance 15\u03a9 C -- E with resistance 3\u03a9 Initial state Final (and reduced) state How the Algorithm Handles Nested Combinations Recursive Reduction: The algorithm inherently handles nested series and parallel combinations through the iterative reduction process. Graph Traversal: Each time a series or parallel pattern is identified and reduced, the graph shrinks and is easier to traverse. Convergence: By continuously reducing series and parallel components, the graph eventually simplifies to only two nodes connected by a single equivalent resistance. This pseudocode outlines the approach for reducing the circuit graph step by step, handling both simple and complex configurations, including nested arrangements. It provides a robust framework for understanding how to algorithmically calculate equivalent resistances using graph theory. For the advanced option involving actual implementation in a programming language, a suitable choice would be Python with libraries such as NetworkX for graph handling, allowing for practical testing of real-world circuit configurations.","title":"Circuits with Graph Theory"},{"location":"Physics/5%20Circuits/Circuits/#circuits-with-graph-theory","text":"","title":"Circuits with Graph Theory"},{"location":"Physics/5%20Circuits/Circuits/#graph-representation","text":"Model the circuit as a graph where nodes represent junctions and edges represent resistors. Each edge has a weight corresponding to the resistance value. Identifying Series and Parallel Connections:","title":"Graph Representation"},{"location":"Physics/5%20Circuits/Circuits/#series-connection","text":"Two nodes connected by a single path without splitting (i.e., no intermediate nodes are shared with other paths).","title":"Series Connection"},{"location":"Physics/5%20Circuits/Circuits/#parallel-connection","text":"Two nodes connected by multiple independent paths. Reduction Process: Start from a complex graph and iteratively reduce it by replacing series and parallel components with their equivalent resistance. Use recursive traversal for nested combinations. Graph edges with resistance values: A -- B with resistance 5\u03a9 A -- C with resistance 2\u03a9 B -- C with resistance 10\u03a9 B -- E with resistance 4\u03a9 C -- D with resistance 15\u03a9 C -- E with resistance 3\u03a9 Initial state Final (and reduced) state How the Algorithm Handles Nested Combinations Recursive Reduction: The algorithm inherently handles nested series and parallel combinations through the iterative reduction process. Graph Traversal: Each time a series or parallel pattern is identified and reduced, the graph shrinks and is easier to traverse. Convergence: By continuously reducing series and parallel components, the graph eventually simplifies to only two nodes connected by a single equivalent resistance. This pseudocode outlines the approach for reducing the circuit graph step by step, handling both simple and complex configurations, including nested arrangements. It provides a robust framework for understanding how to algorithmically calculate equivalent resistances using graph theory. For the advanced option involving actual implementation in a programming language, a suitable choice would be Python with libraries such as NetworkX for graph handling, allowing for practical testing of real-world circuit configurations.","title":"Parallel Connection"},{"location":"Physics/5%20Circuits/ListOfCodes/","text":"List of Codes Sample Circuit import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors and their resistance values # Edges between nodes represent resistors, with weights as resistance values in ohms resistors = { (\"A\", \"B\"): 5, # Resistor between A and B with 5 ohms (\"B\", \"C\"): 10, # Resistor between B and C with 10 ohms (\"C\", \"D\"): 15, # Resistor between C and D with 15 ohms (\"A\", \"D\"): 20 # Resistor between A and D with 20 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define positions for a clear layout pos = { \"A\": (0, 1), \"B\": (1, 2), \"C\": (2, 1), \"D\": (3, 0), } # Draw the graph plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to indicate resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Circuit with Resistances\") plt.axis('off') plt.show() Series Connection import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the series circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors in series # Each pair of nodes is connected by a resistor, representing a series connection resistors = { (\"A\", \"B\"): 5, # Resistor between A and B with 5 ohms (\"B\", \"C\"): 10, # Resistor between B and C with 10 ohms (\"C\", \"D\"): 15 # Resistor between C and D with 15 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define positions for a linear layout to represent series connection pos = { \"A\": (0, 1), \"B\": (1, 1), \"C\": (2, 1), \"D\": (3, 1), } # Draw the graph plt.figure(figsize=(8, 4)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to show resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Series Circuit\") plt.axis('off') plt.show() Parallel Connection import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the parallel circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors in parallel # Each resistor shares the same two nodes (A and B), illustrating parallel connection resistors = { (\"A\", \"B\"): 5, # Resistor R1 between A and B with 5 ohms (\"A\", \"C\"): 10, # Resistor R2 between A and C with 10 ohms (\"A\", \"D\"): 15 # Resistor R3 between A and D with 15 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define a position layout to represent the parallel connection pos = { \"A\": (0, 1), \"B\": (1, 2), \"C\": (1, 1), \"D\": (1, 0), } # Draw the graph plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to show resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Parallel Circuit\") plt.axis('off') plt.show() Recursive import networkx as nx import matplotlib.pyplot as plt def equivalent_resistance_series(resistances): \"\"\"Calculate equivalent resistance for resistors in series.\"\"\" return sum(resistances) def equivalent_resistance_parallel(resistances): \"\"\"Calculate equivalent resistance for resistors in parallel.\"\"\" return 1 / sum(1 / r for r in resistances if r != 0) # Protect against division by zero def draw_graph(G, title): \"\"\"Helper function to draw the graph.\"\"\" plt.figure(figsize=(8, 6)) pos = nx.spring_layout(G) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(title) plt.axis('off') plt.show() def reduce_graph(G, step=0): \"\"\"Recursive reduction of the graph.\"\"\" nodes_to_remove = [] keys_to_remove = [] # Check for series connections: for node in list(G.nodes): if G.degree[node] == 2: # A series node has exactly two connections neighbors = list(G.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors # Calculate equivalent resistance for this series connection resistances = [data['weight'] for _, _, data in G.edges(node, data=True)] series_resistance = equivalent_resistance_series(resistances) # Add a direct edge between n1 and n2 if G.has_edge(n1, n2): # Accumulate the resistance in an existing edge edge_keys = list(G[n1][n2]) G[n1][n2][edge_keys[0]]['weight'] += series_resistance else: # Add a new edge G.add_edge(n1, n2, weight=series_resistance) nodes_to_remove.append(node) G.remove_nodes_from(nodes_to_remove) # Check for parallel connections: edges_to_check = list(G.edges(keys=True, data=True)) for u, v, key, data in edges_to_check: parallel_resistances = [] # Look for parallel edges if G.number_of_edges(u, v) > 1: # Gather all parallel resistances for k in G[u][v]: parallel_resistances.append(G[u][v][k]['weight']) keys_to_remove.append((u, v, k)) # Calculate equivalent resistance parallel_resistance = equivalent_resistance_parallel(parallel_resistances) # Remove all parallel edges and add a single equivalent one for u, v, k in keys_to_remove: G.remove_edge(u, v, k) G.add_edge(u, v, weight=parallel_resistance) # Visualize current graph state draw_graph(G, f\"Graph After Step {step}\") # If any reductions were made, continue to reduce recursively if nodes_to_remove or keys_to_remove: reduce_graph(G, step + 1) def print_graph(G): \"\"\"Helper function to print graph edges with resistance values.\"\"\" print(\"Graph edges with resistance values:\") for u, v, data in G.edges(data=True): print(f\"{u} -- {v} with resistance {data['weight']}\u03a9\") # Create a complex graph G = nx.MultiGraph() # Add nodes and resistors with varying connections for a more complex setup G.add_weighted_edges_from([ ('A', 'B', 5), ('B', 'C', 10), ('C', 'D', 15), ('D', 'E', 20), ('A', 'C', 2), ('C', 'E', 3), ('B', 'E', 4) ]) # Initial graph printout print(\"Initial Graph:\") print_graph(G) draw_graph(G, \"Initial Graph\") # Reduce the graph reduce_graph(G) # Reduced graph printout print(\"\\nReduced Graph:\") print_graph(G)","title":"List of Codes"},{"location":"Physics/5%20Circuits/ListOfCodes/#list-of-codes","text":"","title":"List of Codes"},{"location":"Physics/5%20Circuits/ListOfCodes/#sample-circuit","text":"import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors and their resistance values # Edges between nodes represent resistors, with weights as resistance values in ohms resistors = { (\"A\", \"B\"): 5, # Resistor between A and B with 5 ohms (\"B\", \"C\"): 10, # Resistor between B and C with 10 ohms (\"C\", \"D\"): 15, # Resistor between C and D with 15 ohms (\"A\", \"D\"): 20 # Resistor between A and D with 20 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define positions for a clear layout pos = { \"A\": (0, 1), \"B\": (1, 2), \"C\": (2, 1), \"D\": (3, 0), } # Draw the graph plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to indicate resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Circuit with Resistances\") plt.axis('off') plt.show()","title":"Sample Circuit"},{"location":"Physics/5%20Circuits/ListOfCodes/#series-connection","text":"import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the series circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors in series # Each pair of nodes is connected by a resistor, representing a series connection resistors = { (\"A\", \"B\"): 5, # Resistor between A and B with 5 ohms (\"B\", \"C\"): 10, # Resistor between B and C with 10 ohms (\"C\", \"D\"): 15 # Resistor between C and D with 15 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define positions for a linear layout to represent series connection pos = { \"A\": (0, 1), \"B\": (1, 1), \"C\": (2, 1), \"D\": (3, 1), } # Draw the graph plt.figure(figsize=(8, 4)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to show resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Series Circuit\") plt.axis('off') plt.show()","title":"Series Connection"},{"location":"Physics/5%20Circuits/ListOfCodes/#parallel-connection","text":"import networkx as nx import matplotlib.pyplot as plt # Create an undirected graph for the parallel circuit G = nx.Graph() # Define nodes to represent junctions G.add_nodes_from([\"A\", \"B\", \"C\", \"D\"]) # Define edges with weights to represent resistors in parallel # Each resistor shares the same two nodes (A and B), illustrating parallel connection resistors = { (\"A\", \"B\"): 5, # Resistor R1 between A and B with 5 ohms (\"A\", \"C\"): 10, # Resistor R2 between A and C with 10 ohms (\"A\", \"D\"): 15 # Resistor R3 between A and D with 15 ohms } # Add edges to the graph with the respective resistance weights for (node1, node2), resistance in resistors.items(): G.add_edge(node1, node2, weight=resistance) # Define a position layout to represent the parallel connection pos = { \"A\": (0, 1), \"B\": (1, 2), \"C\": (1, 1), \"D\": (1, 0), } # Draw the graph plt.figure(figsize=(8, 6)) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') # Draw edge labels to show resistance values edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(\"Graph Representation of Parallel Circuit\") plt.axis('off') plt.show()","title":"Parallel Connection"},{"location":"Physics/5%20Circuits/ListOfCodes/#recursive","text":"import networkx as nx import matplotlib.pyplot as plt def equivalent_resistance_series(resistances): \"\"\"Calculate equivalent resistance for resistors in series.\"\"\" return sum(resistances) def equivalent_resistance_parallel(resistances): \"\"\"Calculate equivalent resistance for resistors in parallel.\"\"\" return 1 / sum(1 / r for r in resistances if r != 0) # Protect against division by zero def draw_graph(G, title): \"\"\"Helper function to draw the graph.\"\"\" plt.figure(figsize=(8, 6)) pos = nx.spring_layout(G) nx.draw(G, pos, with_labels=True, node_size=2000, node_color=\"lightblue\", font_size=12, font_weight='bold') edge_labels = nx.get_edge_attributes(G, 'weight') nx.draw_networkx_edge_labels(G, pos, edge_labels={(u, v): f'{w}\u03a9' for u, v, w in G.edges(data='weight')}) plt.title(title) plt.axis('off') plt.show() def reduce_graph(G, step=0): \"\"\"Recursive reduction of the graph.\"\"\" nodes_to_remove = [] keys_to_remove = [] # Check for series connections: for node in list(G.nodes): if G.degree[node] == 2: # A series node has exactly two connections neighbors = list(G.neighbors(node)) if len(neighbors) == 2: n1, n2 = neighbors # Calculate equivalent resistance for this series connection resistances = [data['weight'] for _, _, data in G.edges(node, data=True)] series_resistance = equivalent_resistance_series(resistances) # Add a direct edge between n1 and n2 if G.has_edge(n1, n2): # Accumulate the resistance in an existing edge edge_keys = list(G[n1][n2]) G[n1][n2][edge_keys[0]]['weight'] += series_resistance else: # Add a new edge G.add_edge(n1, n2, weight=series_resistance) nodes_to_remove.append(node) G.remove_nodes_from(nodes_to_remove) # Check for parallel connections: edges_to_check = list(G.edges(keys=True, data=True)) for u, v, key, data in edges_to_check: parallel_resistances = [] # Look for parallel edges if G.number_of_edges(u, v) > 1: # Gather all parallel resistances for k in G[u][v]: parallel_resistances.append(G[u][v][k]['weight']) keys_to_remove.append((u, v, k)) # Calculate equivalent resistance parallel_resistance = equivalent_resistance_parallel(parallel_resistances) # Remove all parallel edges and add a single equivalent one for u, v, k in keys_to_remove: G.remove_edge(u, v, k) G.add_edge(u, v, weight=parallel_resistance) # Visualize current graph state draw_graph(G, f\"Graph After Step {step}\") # If any reductions were made, continue to reduce recursively if nodes_to_remove or keys_to_remove: reduce_graph(G, step + 1) def print_graph(G): \"\"\"Helper function to print graph edges with resistance values.\"\"\" print(\"Graph edges with resistance values:\") for u, v, data in G.edges(data=True): print(f\"{u} -- {v} with resistance {data['weight']}\u03a9\") # Create a complex graph G = nx.MultiGraph() # Add nodes and resistors with varying connections for a more complex setup G.add_weighted_edges_from([ ('A', 'B', 5), ('B', 'C', 10), ('C', 'D', 15), ('D', 'E', 20), ('A', 'C', 2), ('C', 'E', 3), ('B', 'E', 4) ]) # Initial graph printout print(\"Initial Graph:\") print_graph(G) draw_graph(G, \"Initial Graph\") # Reduce the graph reduce_graph(G) # Reduced graph printout print(\"\\nReduced Graph:\") print_graph(G)","title":"Recursive"},{"location":"Physics/6%20Statistics/ListOfCodes/","text":"","title":"ListOfCodes"},{"location":"Physics/6%20Statistics/Problem_1/","text":"1. Simulating Sampling Distributions The Central Limit Theorem (CLT) is a fundamental concept in statistics that states that the sampling distribution of the sample mean (or sum) of a sufficiently large number of independent, identically distributed variables approaches a normal distribution, regardless of the original distribution of the population. This property makes CLT an essential tool in various real-world scenarios for the following reasons: Estimating Population Parameters Importance: The CLT allows statisticians to make inferences about a population even when the population distribution is unknown or not normal. By calculating the mean of a sample and knowing that this sample mean is normally distributed (given a large enough sample size), statisticians can: Infer Population Mean: Estimate the true population mean and construct confidence intervals to express the precision of the estimate.Hypothesis Testing: Use inferential statistics to test assumptions or hypotheses about the population parameters.Application: In medical research, for example, researchers often want to estimate the average effect of a drug on the entire population. Using the CLT, even if the distribution of effects is non-normal, they can rely on the sample mean distribution to make accurate predictions and decisions. Quality Control in Manufacturing Importance: In manufacturing, quality control is essential for ensuring that products meet certain standards. The CLT is crucial here for: Process Control: Enables the use of statistical process control charts, which help monitor whether a manufacturing process is in control or if it shows variations that need correction.Tolerance Limits: Helps in setting tolerances for product dimensions and performance metrics, knowing that the distribution of sample means would follow a normal distribution.Application: For example, in automotive manufacturing, dimensions of a critical component like a piston ring are sampled. Using CLT, manufacturers can determine if production is consistent or if there is a statistical anomaly that may indicate a problem in the manufacturing process. Predicting Outcomes in Financial Models Importance: The CLT is critical in finance for modeling and predicting various financial outcomes. Financial models often assume normal distribution due to CLT, even when the actual data distribution might not be normal, allowing for: Risk Management: Use of value-at-risk (VaR) models, which estimate the potential loss in value of a portfolio with a given confidence interval.Option Pricing Models: Assumptions of normality in distribution help in the application of models like the Black-Scholes, which depend on stock price modeling.Application: Portfolio managers use historical return data and the CLT to assess and predict the risk and return characteristics of investment portfolios. By assuming the returns are normally distributed (post-CLT adjustments), they can calculate expected returns, variances, and probabilities of extreme losses. Summary The CLT provides a powerful framework that simplifies complex data analysis by allowing researchers and practitioners in various fields to use the properties of the normal distribution to make statistical inferences. This simplification is essential across disciplines, leading to more effective decision-making processes, from setting production standards in manufacturing to making informed financial investment decisions. The CLT thus underpins much of the practical work in fields where robust statistical analysis is required.","title":"1. Simulating Sampling Distributions"},{"location":"Physics/6%20Statistics/Problem_1/#1-simulating-sampling-distributions","text":"The Central Limit Theorem (CLT) is a fundamental concept in statistics that states that the sampling distribution of the sample mean (or sum) of a sufficiently large number of independent, identically distributed variables approaches a normal distribution, regardless of the original distribution of the population. This property makes CLT an essential tool in various real-world scenarios for the following reasons:","title":"1. Simulating Sampling Distributions"},{"location":"Physics/6%20Statistics/Problem_1/#estimating-population-parameters","text":"Importance: The CLT allows statisticians to make inferences about a population even when the population distribution is unknown or not normal. By calculating the mean of a sample and knowing that this sample mean is normally distributed (given a large enough sample size), statisticians can: Infer Population Mean: Estimate the true population mean and construct confidence intervals to express the precision of the estimate.Hypothesis Testing: Use inferential statistics to test assumptions or hypotheses about the population parameters.Application: In medical research, for example, researchers often want to estimate the average effect of a drug on the entire population. Using the CLT, even if the distribution of effects is non-normal, they can rely on the sample mean distribution to make accurate predictions and decisions.","title":"Estimating Population Parameters"},{"location":"Physics/6%20Statistics/Problem_1/#quality-control-in-manufacturing","text":"Importance: In manufacturing, quality control is essential for ensuring that products meet certain standards. The CLT is crucial here for: Process Control: Enables the use of statistical process control charts, which help monitor whether a manufacturing process is in control or if it shows variations that need correction.Tolerance Limits: Helps in setting tolerances for product dimensions and performance metrics, knowing that the distribution of sample means would follow a normal distribution.Application: For example, in automotive manufacturing, dimensions of a critical component like a piston ring are sampled. Using CLT, manufacturers can determine if production is consistent or if there is a statistical anomaly that may indicate a problem in the manufacturing process.","title":"Quality Control in Manufacturing"},{"location":"Physics/6%20Statistics/Problem_1/#predicting-outcomes-in-financial-models","text":"Importance: The CLT is critical in finance for modeling and predicting various financial outcomes. Financial models often assume normal distribution due to CLT, even when the actual data distribution might not be normal, allowing for: Risk Management: Use of value-at-risk (VaR) models, which estimate the potential loss in value of a portfolio with a given confidence interval.Option Pricing Models: Assumptions of normality in distribution help in the application of models like the Black-Scholes, which depend on stock price modeling.Application: Portfolio managers use historical return data and the CLT to assess and predict the risk and return characteristics of investment portfolios. By assuming the returns are normally distributed (post-CLT adjustments), they can calculate expected returns, variances, and probabilities of extreme losses. Summary The CLT provides a powerful framework that simplifies complex data analysis by allowing researchers and practitioners in various fields to use the properties of the normal distribution to make statistical inferences. This simplification is essential across disciplines, leading to more effective decision-making processes, from setting production standards in manufacturing to making informed financial investment decisions. The CLT thus underpins much of the practical work in fields where robust statistical analysis is required.","title":"Predicting Outcomes in Financial Models"},{"location":"Physics/6%20Statistics/Problem_2/","text":"2. Monte Carlo Simulations Monte Carlo simulations are a computational technique used to estimate mathematical expressions and solve problems that might be deterministic in principle. In this context, we'll use Monte Carlo simulations to estimate the value of \u03c0 by simulating random points in a square and determining how many fall inside a quarter circle. Concept Formula Derivation A unit circle is defined by the equation \\(x^2 + y^2 = 1\\) , which describes a circle with radius 1 centered at the origin (0, 0).To estimate \u03c0 using Monte Carlo simulation, consider a quarter circle (since our computations will be easier with positive x and y). Geometric Insight Inside a square of side length 2, draw a quarter of a unit circle with radius 1.The area of the square is \\(1 \\times 1 = 1\\) .The area of the quarter circle is \\(\\frac{1}{4}\\pi\\) . Monte Carlo Simulation Randomly generate points within the square.Count the number of points that fall within the quarter circle using \\(x^2 + y^2 \\leq 1\\) .The ratio of points inside the circle to the total number of points approximates the area of the quarter circle. Thus, the formula for \u03c0 is derived as \\(\\pi \\approx 4 \\times (\\text{points inside the circle} / \\text{total points})\\) . To analyze how the accuracy of the \u03c0 estimate improves with an increasing number of points, we can perform multiple Monte Carlo simulations with different numbers of points and observe the convergence of the estimated \u03c0 value. The more points used, the closer the estimate should approach the true value of \u03c0 due to the law of large numbers. Convergence Rate Convergence The Monte Carlo method converges at a rate proportional to \\(\\frac{1}{\\sqrt{N}}\\) , where \\(N\\) is the number of points. This means that to improve accuracy by a factor of 10, you need 100 times more points.Efficiency: Although Monte Carlo methods are relatively simple and versatile, they can require a large number of points for high accuracy due to their slow convergence rate. Computational Considerations Trade-off There is a trade-off between computational time and accuracy. More points yield better estimates but require more computational resources and time. Performance Modern computers can handle millions of points quickly, but efficient implementations and optimizations (e.g., vectorized operations in NumPy) are crucial for performance. Other Aplications Monte Carlo simulations can be applied to a wide range of problems involving uncertainty and variability. Here are several examples of simulations that could be conducted using Monte Carlo methods alongside a regional map of Poland: 1. Economic Activity Simulation Objective: Simulate the variation in economic output, such as GDP per capita or total GDP by region.Data Needed: Historical economic data, growth rates, inflation rates.Analysis: Visualize potential economic outcomes for different regions based on varying growth assumptions. 2. Population Growth Forecast Objective: Model the population growth trends for each region up to a future year (e.g., 2030), taking into account factors such as birth rates, death rates, and migration.Data Needed: Current population, birth/death rates, migration trends.Analysis: Assess the impacts on infrastructure, housing needs, and service demands. 3. Healthcare Resource Allocation Objective: Evaluate the distribution of healthcare resources under varying demand scenarios, influenced by factors like disease outbreak or an aging population.Data Needed: Current healthcare resources, historical usage data, demographic trends.Analysis: Optimize resource allocation strategies to cope with uncertain demand peaks. 4. Infrastructure Development Risk Assessment Objective: Assess the potential financial and scheduling risks involved in large infrastructure projects across regions.Data Needed: Projected costs, timelines, and historical risk factors impacting infrastructure projects.Analysis: Identify high-risk areas and strategize mitigation efforts. 5. Environmental and Climate Impact Projections Objective: Predict environmental impacts, such as pollution or climate change effects, under different scenarios.Data Needed: Historical environmental data, emission rates, and climate model predictions.Analysis: Use scenarios to develop regional climate action plans or pollution control measures. 6. Transportation and Traffic Flow Modelling Objective: Simulate traffic patterns and regional transportation demand to aid in planning and resource allocation.Data Needed: Traffic data, road network information, public transport usage.Analysis: Improve infrastructure planning and prioritize future transport projects. 7. Agricultural Yield Prediction Objective: Estimate variability in agricultural output due to changing weather patterns, input costs, and market conditions.Data Needed: Historical yield data, weather forecasts, market trends.Analysis: Plan supply chains and pricing to optimize profitability under uncertain conditions. 8. Educational Outcomes Estimation Objective: Predict educational achievements and demands based on demographic trends, investment levels, and policy changes.Data Needed: Current educational data, population trends, policy parameters.Analysis: Develop policies to improve educational outcomes and resource distribution. Specific Simulation (a) Education, (b) Population Forecast","title":"2. Monte Carlo Simulations"},{"location":"Physics/6%20Statistics/Problem_2/#2-monte-carlo-simulations","text":"Monte Carlo simulations are a computational technique used to estimate mathematical expressions and solve problems that might be deterministic in principle. In this context, we'll use Monte Carlo simulations to estimate the value of \u03c0 by simulating random points in a square and determining how many fall inside a quarter circle.","title":"2. Monte Carlo Simulations"},{"location":"Physics/6%20Statistics/Problem_2/#concept","text":"","title":"Concept"},{"location":"Physics/6%20Statistics/Problem_2/#formula-derivation","text":"A unit circle is defined by the equation \\(x^2 + y^2 = 1\\) , which describes a circle with radius 1 centered at the origin (0, 0).To estimate \u03c0 using Monte Carlo simulation, consider a quarter circle (since our computations will be easier with positive x and y).","title":"Formula Derivation"},{"location":"Physics/6%20Statistics/Problem_2/#geometric-insight","text":"Inside a square of side length 2, draw a quarter of a unit circle with radius 1.The area of the square is \\(1 \\times 1 = 1\\) .The area of the quarter circle is \\(\\frac{1}{4}\\pi\\) .","title":"Geometric Insight"},{"location":"Physics/6%20Statistics/Problem_2/#monte-carlo-simulation","text":"Randomly generate points within the square.Count the number of points that fall within the quarter circle using \\(x^2 + y^2 \\leq 1\\) .The ratio of points inside the circle to the total number of points approximates the area of the quarter circle. Thus, the formula for \u03c0 is derived as \\(\\pi \\approx 4 \\times (\\text{points inside the circle} / \\text{total points})\\) . To analyze how the accuracy of the \u03c0 estimate improves with an increasing number of points, we can perform multiple Monte Carlo simulations with different numbers of points and observe the convergence of the estimated \u03c0 value. The more points used, the closer the estimate should approach the true value of \u03c0 due to the law of large numbers.","title":"Monte Carlo Simulation"},{"location":"Physics/6%20Statistics/Problem_2/#convergence-rate","text":"","title":"Convergence Rate"},{"location":"Physics/6%20Statistics/Problem_2/#convergence","text":"The Monte Carlo method converges at a rate proportional to \\(\\frac{1}{\\sqrt{N}}\\) , where \\(N\\) is the number of points. This means that to improve accuracy by a factor of 10, you need 100 times more points.Efficiency: Although Monte Carlo methods are relatively simple and versatile, they can require a large number of points for high accuracy due to their slow convergence rate.","title":"Convergence"},{"location":"Physics/6%20Statistics/Problem_2/#computational-considerations","text":"","title":"Computational Considerations"},{"location":"Physics/6%20Statistics/Problem_2/#trade-off","text":"There is a trade-off between computational time and accuracy. More points yield better estimates but require more computational resources and time.","title":"Trade-off"},{"location":"Physics/6%20Statistics/Problem_2/#performance","text":"Modern computers can handle millions of points quickly, but efficient implementations and optimizations (e.g., vectorized operations in NumPy) are crucial for performance.","title":"Performance"},{"location":"Physics/6%20Statistics/Problem_2/#other-aplications","text":"Monte Carlo simulations can be applied to a wide range of problems involving uncertainty and variability. Here are several examples of simulations that could be conducted using Monte Carlo methods alongside a regional map of Poland:","title":"Other Aplications"},{"location":"Physics/6%20Statistics/Problem_2/#1-economic-activity-simulation","text":"Objective: Simulate the variation in economic output, such as GDP per capita or total GDP by region.Data Needed: Historical economic data, growth rates, inflation rates.Analysis: Visualize potential economic outcomes for different regions based on varying growth assumptions.","title":"1. Economic Activity Simulation"},{"location":"Physics/6%20Statistics/Problem_2/#2-population-growth-forecast","text":"Objective: Model the population growth trends for each region up to a future year (e.g., 2030), taking into account factors such as birth rates, death rates, and migration.Data Needed: Current population, birth/death rates, migration trends.Analysis: Assess the impacts on infrastructure, housing needs, and service demands.","title":"2. Population Growth Forecast"},{"location":"Physics/6%20Statistics/Problem_2/#3-healthcare-resource-allocation","text":"Objective: Evaluate the distribution of healthcare resources under varying demand scenarios, influenced by factors like disease outbreak or an aging population.Data Needed: Current healthcare resources, historical usage data, demographic trends.Analysis: Optimize resource allocation strategies to cope with uncertain demand peaks.","title":"3. Healthcare Resource Allocation"},{"location":"Physics/6%20Statistics/Problem_2/#4-infrastructure-development-risk-assessment","text":"Objective: Assess the potential financial and scheduling risks involved in large infrastructure projects across regions.Data Needed: Projected costs, timelines, and historical risk factors impacting infrastructure projects.Analysis: Identify high-risk areas and strategize mitigation efforts.","title":"4. Infrastructure Development Risk Assessment"},{"location":"Physics/6%20Statistics/Problem_2/#5-environmental-and-climate-impact-projections","text":"Objective: Predict environmental impacts, such as pollution or climate change effects, under different scenarios.Data Needed: Historical environmental data, emission rates, and climate model predictions.Analysis: Use scenarios to develop regional climate action plans or pollution control measures.","title":"5. Environmental and Climate Impact Projections"},{"location":"Physics/6%20Statistics/Problem_2/#6-transportation-and-traffic-flow-modelling","text":"Objective: Simulate traffic patterns and regional transportation demand to aid in planning and resource allocation.Data Needed: Traffic data, road network information, public transport usage.Analysis: Improve infrastructure planning and prioritize future transport projects.","title":"6. Transportation and Traffic Flow Modelling"},{"location":"Physics/6%20Statistics/Problem_2/#7-agricultural-yield-prediction","text":"Objective: Estimate variability in agricultural output due to changing weather patterns, input costs, and market conditions.Data Needed: Historical yield data, weather forecasts, market trends.Analysis: Plan supply chains and pricing to optimize profitability under uncertain conditions.","title":"7. Agricultural Yield Prediction"},{"location":"Physics/6%20Statistics/Problem_2/#8-educational-outcomes-estimation","text":"Objective: Predict educational achievements and demands based on demographic trends, investment levels, and policy changes.Data Needed: Current educational data, population trends, policy parameters.Analysis: Develop policies to improve educational outcomes and resource distribution.","title":"8. Educational Outcomes Estimation"},{"location":"Physics/6%20Statistics/Problem_2/#specific-simulation-a-education-b-population-forecast","text":"","title":"Specific Simulation (a) Education, (b) Population Forecast"},{"location":"Physics/6%20Statistics/zListOfCodes/","text":"3. List of Codes Sampling - 5/10/20/30/50 import numpy as np import matplotlib.pyplot as plt import ipywidgets as widgets from IPython.display import display # Function to create sampling distributions and plot histograms def plot_sampling_distribution(sample_size): # Sampling function def sampling_distribution(population, sample_size, num_samples=1000): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size) sample_means.append(np.mean(sample)) return sample_means plt.figure(figsize=(18, 6)) distributions = { 'Uniform': uniform_population, 'Exponential': exponential_population, 'Binomial': binomial_population } for i, (name, population) in enumerate(distributions.items()): # Calculate sample means sample_means = sampling_distribution(population, sample_size) # Plot histogram plt.subplot(1, 3, i + 1) plt.hist(sample_means, bins=30, density=True, alpha=0.7, color='b', edgecolor='black') plt.title(f'{name} Distribution\\nSample Size = {sample_size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') # Calculate and display variance variance = np.var(sample_means) plt.annotate(f'Variance: {variance:.4f}', xy=(0.7, 0.7), xycoords='axes fraction') plt.tight_layout() plt.show() # Generate populations population_size = 100000 uniform_population = np.random.uniform(low=0.0, high=1.0, size=population_size) exponential_population = np.random.exponential(scale=1.0, size=population_size) binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) # Create an interactive widget sample_size_slider = widgets.IntSlider( value=5, min=5, max=50, step=5, description='Sample Size:', continuous_update=False, ) # Display interactive plot interactive_plot = widgets.interactive(plot_sampling_distribution, sample_size=sample_size_slider) display(interactive_plot) Estimating Pi import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points: int) -> float: x_points = np.random.uniform(0, 1, num_points) y_points = np.random.uniform(0, 1, num_points) inside_circle = x_points**2 + y_points**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate # Define the range of point numbers to test points_list = [10, 100, 1000, 10000, 100000, 1000000] # Store the estimates and deviations pi_estimates = [] deviations = [] # Run the simulation for each number of points for num_points in points_list: pi_estimate = monte_carlo_pi(num_points) pi_estimates.append(pi_estimate) deviations.append(abs(pi_estimate - np.pi)) # Plotting the results plt.figure(figsize=(12, 6)) # Subplot 1: Estimated \u03c0 vs. Number of Points plt.subplot(1, 2, 1) plt.plot(points_list, pi_estimates, marker='o', linestyle='-') plt.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') plt.xscale('log') plt.title('Estimated \u03c0 vs. Number of Points') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) # Subplot 2: Error in Estimate vs. Number of Points plt.subplot(1, 2, 2) plt.plot(points_list, deviations, marker='o', linestyle='-') plt.xscale('log') plt.yscale('log') plt.title('Error in Estimate vs. Number of Points') plt.xlabel('Number of Points (log scale)') plt.ylabel('Error in Estimate') plt.grid(True) plt.tight_layout() plt.show() [2021 Enrollees vs 2026 Graduates (Approx) import numpy as np import matplotlib.pyplot as plt def monte_carlo_enrollees_vs_graduates(num_simulations: int, graduate_rate: float) -> np.ndarray: # Simulate uniformly distributed 2021 enrollees in a unit square enrollees_x = np.random.uniform(0, 1, num_simulations) enrollees_y = np.random.uniform(0, 1, num_simulations) # Calculate a new distribution for 2025 graduates graduates_x = enrollees_x # Assume x-coordinates remain the same for simplicity graduates_y = graduate_rate * enrollees_y + np.random.normal(0, 0.1, num_simulations) # Plot the simulation results plt.figure(figsize=(8, 8)) plt.scatter(enrollees_x, enrollees_y, color='lightgreen', s=10, alpha=0.5, label='2021 Enrollees') plt.scatter(graduates_x, graduates_y, color='orange', s=10, alpha=0.5, edgecolors='red', linewidth=0.5, label='2025 Graduates') plt.title(\"Monte Carlo Simulation: Enrollees vs Graduates\") plt.xlabel(\"Normalized Enrollee ID\") plt.ylabel(\"Normalized Enrollment Level / Graduation Level\") plt.xlim(0, 1) plt.ylim(0, 1) plt.grid(True) plt.gca().set_aspect('equal', adjustable='box') plt.legend() plt.show() return (enrollees_x, enrollees_y), (graduates_x, graduates_y) # Run the simulation with a specified number of simulations and graduate rate enrollees, graduates = monte_carlo_enrollees_vs_graduates(num_simulations=10000, graduate_rate=0.8) 2050 Poland Population by Region (Forecast) ximport geopandas as gpd import numpy as np import matplotlib.pyplot as plt # Setting file path file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Reading specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names and verification poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Print to verify names from GeoDataFrame print(\"Regions from GeoDataFrame:\") print(poland_gdf['name'].unique()) # Reproject to a suitable CRS for Poland (EPSG:2180) poland_gdf = poland_gdf.to_crs(epsg=2180) # Define current population data dictionary current_population_2022 = { 'Lower Silesian': 2904457, 'Kuyavian-Pomeranian': 2083563, 'Lublin': 2119854, 'Lubusz': 1005630, '\u0141\u00f3d\u017a': 2436348, 'Lesser Poland': 3360428, 'Masovian': 5421823, 'Opole': 982249, 'Subcarpathian': 2128203, 'Podlachian': 1188866, 'Pomeranian': 2329218, 'Silesian': 4455701, '\u015awi\u0119tokrzyskie': 1216949, 'Warmian-Masurian': 1423965, 'Greater Poland': 3475329, 'West Pomeranian': 1687128 } # Define mapping for names name_map = { 'Dolno\u015bl\u0105skie': 'Lower Silesian', 'Kujawsko-Pomorskie': 'Kuyavian-Pomeranian', 'Lubelskie': 'Lublin', 'Lubuskie': 'Lubusz', '\u0141\u00f3dzkie': '\u0141\u00f3d\u017a', 'Ma\u0142opolskie': 'Lesser Poland', 'Mazowieckie': 'Masovian', 'Opolskie': 'Opole', 'Podkarpackie': 'Subcarpathian', 'Podlaskie': 'Podlachian', 'Pomorskie': 'Pomeranian', '\u015al\u0105skie': 'Silesian', '\u015awi\u0119tokrzyskie': '\u015awi\u0119tokrzyskie', 'Warmi\u0144sko-Mazurskie': 'Warmian-Masurian', 'Wielkopolskie': 'Greater Poland', 'Zachodniopomorskie': 'West Pomeranian' } # Simulation setup years = 2050 - 2022 iterations = 1000 growth_rate_mean = 0.005 growth_rate_std = 0.004 # Monte Carlo simulation projection_results = {region: [] for region in current_population_2022.keys()} for region, initial_population in current_population_2022.items(): for _ in range(iterations): population = initial_population for year in range(years): growth_rate = np.random.normal(growth_rate_mean, growth_rate_std) growth_rate = 1 if growth_rate == 0 else growth_rate population += population * growth_rate projection_results[region].append(population) # Function to map population using updated methodology def map_population(region_name): simulation_name = region_name if simulation_name is not None: return np.mean(projection_results[simulation_name]) else: return np.nan # Population projection poland_gdf['projected_population_2050'] = poland_gdf['name'].apply(map_population) # Print regions with NaN values print(\"Regions with NaN values after mapping:\") print(poland_gdf[poland_gdf['projected_population_2050'].isna()]['name']) # Plotting the results fig, ax = plt.subplots(1, 1, figsize=(12, 10)) poland_gdf.boundary.plot(ax=ax, linewidth=1) poland_gdf.plot(ax=ax, column='projected_population_2050', cmap='YlOrRd', legend=True) ax.set_title(\"Projected Population in 2050 in Poland by Region (Monte Carlo)\") ax.axis('off') # Add region names for x, y, label in zip(poland_gdf.geometry.centroid.x, poland_gdf.geometry.centroid.y, poland_gdf['name']): ax.text(x, y, label, fontsize=8, ha='center', va='center', color='black', alpha=0.6) plt.show() 2026 Masovian Region Population by Age group (Forecast) import geopandas as gpd import numpy as np import matplotlib.pyplot as plt from shapely.geometry import Polygon # Set file path for the shapefile file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Read specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Filter GeoDataFrame to retain only the Masovian region masovian_gdf = poland_gdf[poland_gdf['name'] == 'Masovian'] # Reproject to a suitable CRS for Poland (EPSG:2180) masovian_gdf = masovian_gdf.to_crs(epsg=2180) # Current population for Masovian region current_population_masovian = 5421823 # Hypothetical age distribution percentages for the Masovian population age_distribution_percentages = { '1-12': 0.15, # 15% '13-18': 0.10, # 10% '19-35': 0.30, # 30% '36-50': 0.25, # 25% '>50': 0.20 # 20% } # Calculate initial population by age group initial_age_group_populations = { group: current_population_masovian * percentage for group, percentage in age_distribution_percentages.items() } # Simulation setup for Masovian region years = 2026 - 2022 iterations = 100 growth_rate_mean = 0.005 growth_rate_std = 0.004 # Monte Carlo simulation for each age group projection_results_by_age_group = {group: [] for group in initial_age_group_populations} for group, initial_population in initial_age_group_populations.items(): for _ in range(iterations): population = initial_population for year in range(years): growth_rate = np.random.normal(growth_rate_mean, growth_rate_std) population += population * growth_rate projection_results_by_age_group[group].append(population) # Calculate the mean of the simulated values for 2026 population for each age group mean_projected_population_by_age_group = { group: np.mean(populations) for group, populations in projection_results_by_age_group.items() } # Calculate the distribution of areas based on the simulated projected populations total_simulated_population = sum(mean_projected_population_by_age_group.values()) age_areas = {group: total_simulated_population * age_distribution_percentages[group] for group in mean_projected_population_by_age_group} # Generate sub-regions within Masovian based on these simulated projections total_area = masovian_gdf.geometry.area.iloc[0] original_geom = masovian_gdf.geometry.iloc[0] minx, miny, maxx, maxy = original_geom.bounds # Divide the region into vertical strips representing areas for different age groups current_minx = minx age_geometries = [] for age, volume in age_areas.items(): age_width = (volume / total_simulated_population) * (maxx - minx) geom_slice = original_geom.intersection(Polygon([(current_minx, miny), (current_minx + age_width, miny), (current_minx + age_width, maxy), (current_minx, maxy)])) age_geometries.append((age, geom_slice)) current_minx += age_width # Create a new GeoDataFrame for these simulated areas with projected populations age_gdf = gpd.GeoDataFrame({ 'age_group': [age for age, geom in age_geometries], 'geometry': [geom for age, geom in age_geometries], 'population_millions': [mean_projected_population_by_age_group[age] / 1e6 for age, geom in age_geometries], 'percentage': [age_distribution_percentages[age] * 100 for age, geom in age_geometries] }, crs=masovian_gdf.crs) # Plot the Masovian region with age group areas based on Monte Carlo projections fig, ax = plt.subplots(1, 1, figsize=(10, 8)) age_gdf.boundary.plot(ax=ax, color='black', linewidth=0.8) age_gdf.plot(ax=ax, column='age_group', cmap='Accent', legend=True, edgecolor='black', alpha=0.75) ax.set_title(\"Projected Age Group Areas in Masovian Region (Monte Carlo Simulation)\") ax.axis('off') # Annotate the areas with age group names, percentages, and population in millions for x, y, label, perc, pop in zip(age_gdf.geometry.centroid.x, age_gdf.geometry.centroid.y, age_gdf['age_group'], age_gdf['percentage'], age_gdf['population_millions']): ax.text(x, y, f\"{label}\\n{perc:.1f}%\\n{pop:.2f}M\", fontsize=10, ha='center', va='center', color='black', alpha=0.7) plt.show() Masovian Region Population Ages 13-18 import geopandas as gpd import numpy as np import matplotlib.pyplot as plt from shapely.geometry import Point # Set file path for the shapefile file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Read specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Filter GeoDataFrame to retain only the Masovian region masovian_gdf = poland_gdf[poland_gdf['name'] == 'Masovian'] # Reproject to a suitable CRS for Poland (EPSG:2180) masovian_gdf = masovian_gdf.to_crs(epsg=2180) # Define the population distribution for each specific age between 13 and 18 # Assuming equal distribution for simplification; these should be adjusted with real data if available age_distribution_percentages = { 13: 0.0167 * 4, # ~1.67% 14: 0.0167 / 4, 15: 0.0167 * 3, 16: 0.0167 / 3, 17: 0.0167 * 2, 18: 0.0167 / 2 } # Total population for ages 13-18 current_population_masovian = 5421823 population_ages_13_to_18 = current_population_masovian * sum(age_distribution_percentages.values()) # Adjust to total percentage if needed # Simulate data points for each individual age in the Masovian region ages = list(age_distribution_percentages.keys()) points_by_age = {age: [] for age in ages} num_simulations = 1000 # Total number of points to simulate across these ages minx, miny, maxx, maxy = masovian_gdf.total_bounds # Generate random points within the region for each age for age in ages: num_points = int(num_simulations * age_distribution_percentages[age]) # Proportional split # Print regions with NaN values print(\"Age Population Probability\", age, \":\", ((age_distribution_percentages[age] * current_population_masovian) / population_ages_13_to_18) * 100) for _ in range(num_points): while True: x = np.random.uniform(minx, maxx) y = np.random.uniform(miny, maxy) point = Point(x, y) if point.within(masovian_gdf.geometry.iloc[0]): points_by_age[age].append(point) break # Plot points within the Masovian region, differentiating by age fig, ax = plt.subplots(1, 1, figsize=(12, 10)) masovian_gdf.boundary.plot(ax=ax, color='black', linewidth=0.8) # Colors and labels for plotting different ages colors = ['red', 'green', 'blue', 'purple', 'cyan', 'orange'] for age, color in zip(ages, colors): # Create a GeoDataFrame for these points points_gdf = gpd.GeoDataFrame(geometry=points_by_age[age], crs=masovian_gdf.crs) points_gdf.plot(ax=ax, color=color, marker='o', markersize=5, alpha=0.7, label=f'Age {age}') ax.set_title(\" Simulated Distribution of Ages 13-18 in Masovian Region\") ax.axis('off') ax.legend(loc='upper right') plt.show()","title":"3. List of Codes"},{"location":"Physics/6%20Statistics/zListOfCodes/#3-list-of-codes","text":"","title":"3. List of Codes"},{"location":"Physics/6%20Statistics/zListOfCodes/#sampling-510203050","text":"import numpy as np import matplotlib.pyplot as plt import ipywidgets as widgets from IPython.display import display # Function to create sampling distributions and plot histograms def plot_sampling_distribution(sample_size): # Sampling function def sampling_distribution(population, sample_size, num_samples=1000): sample_means = [] for _ in range(num_samples): sample = np.random.choice(population, size=sample_size) sample_means.append(np.mean(sample)) return sample_means plt.figure(figsize=(18, 6)) distributions = { 'Uniform': uniform_population, 'Exponential': exponential_population, 'Binomial': binomial_population } for i, (name, population) in enumerate(distributions.items()): # Calculate sample means sample_means = sampling_distribution(population, sample_size) # Plot histogram plt.subplot(1, 3, i + 1) plt.hist(sample_means, bins=30, density=True, alpha=0.7, color='b', edgecolor='black') plt.title(f'{name} Distribution\\nSample Size = {sample_size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') # Calculate and display variance variance = np.var(sample_means) plt.annotate(f'Variance: {variance:.4f}', xy=(0.7, 0.7), xycoords='axes fraction') plt.tight_layout() plt.show() # Generate populations population_size = 100000 uniform_population = np.random.uniform(low=0.0, high=1.0, size=population_size) exponential_population = np.random.exponential(scale=1.0, size=population_size) binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) # Create an interactive widget sample_size_slider = widgets.IntSlider( value=5, min=5, max=50, step=5, description='Sample Size:', continuous_update=False, ) # Display interactive plot interactive_plot = widgets.interactive(plot_sampling_distribution, sample_size=sample_size_slider) display(interactive_plot)","title":"Sampling - 5/10/20/30/50"},{"location":"Physics/6%20Statistics/zListOfCodes/#estimating-pi","text":"import numpy as np import matplotlib.pyplot as plt def monte_carlo_pi(num_points: int) -> float: x_points = np.random.uniform(0, 1, num_points) y_points = np.random.uniform(0, 1, num_points) inside_circle = x_points**2 + y_points**2 <= 1 pi_estimate = 4 * np.sum(inside_circle) / num_points return pi_estimate # Define the range of point numbers to test points_list = [10, 100, 1000, 10000, 100000, 1000000] # Store the estimates and deviations pi_estimates = [] deviations = [] # Run the simulation for each number of points for num_points in points_list: pi_estimate = monte_carlo_pi(num_points) pi_estimates.append(pi_estimate) deviations.append(abs(pi_estimate - np.pi)) # Plotting the results plt.figure(figsize=(12, 6)) # Subplot 1: Estimated \u03c0 vs. Number of Points plt.subplot(1, 2, 1) plt.plot(points_list, pi_estimates, marker='o', linestyle='-') plt.axhline(y=np.pi, color='r', linestyle='--', label='True \u03c0') plt.xscale('log') plt.title('Estimated \u03c0 vs. Number of Points') plt.xlabel('Number of Points (log scale)') plt.ylabel('Estimated \u03c0') plt.legend() plt.grid(True) # Subplot 2: Error in Estimate vs. Number of Points plt.subplot(1, 2, 2) plt.plot(points_list, deviations, marker='o', linestyle='-') plt.xscale('log') plt.yscale('log') plt.title('Error in Estimate vs. Number of Points') plt.xlabel('Number of Points (log scale)') plt.ylabel('Error in Estimate') plt.grid(True) plt.tight_layout() plt.show()","title":"Estimating Pi"},{"location":"Physics/6%20Statistics/zListOfCodes/#2021-enrollees-vs-2026-graduates-approx","text":"import numpy as np import matplotlib.pyplot as plt def monte_carlo_enrollees_vs_graduates(num_simulations: int, graduate_rate: float) -> np.ndarray: # Simulate uniformly distributed 2021 enrollees in a unit square enrollees_x = np.random.uniform(0, 1, num_simulations) enrollees_y = np.random.uniform(0, 1, num_simulations) # Calculate a new distribution for 2025 graduates graduates_x = enrollees_x # Assume x-coordinates remain the same for simplicity graduates_y = graduate_rate * enrollees_y + np.random.normal(0, 0.1, num_simulations) # Plot the simulation results plt.figure(figsize=(8, 8)) plt.scatter(enrollees_x, enrollees_y, color='lightgreen', s=10, alpha=0.5, label='2021 Enrollees') plt.scatter(graduates_x, graduates_y, color='orange', s=10, alpha=0.5, edgecolors='red', linewidth=0.5, label='2025 Graduates') plt.title(\"Monte Carlo Simulation: Enrollees vs Graduates\") plt.xlabel(\"Normalized Enrollee ID\") plt.ylabel(\"Normalized Enrollment Level / Graduation Level\") plt.xlim(0, 1) plt.ylim(0, 1) plt.grid(True) plt.gca().set_aspect('equal', adjustable='box') plt.legend() plt.show() return (enrollees_x, enrollees_y), (graduates_x, graduates_y) # Run the simulation with a specified number of simulations and graduate rate enrollees, graduates = monte_carlo_enrollees_vs_graduates(num_simulations=10000, graduate_rate=0.8)","title":"[2021 Enrollees vs 2026 Graduates (Approx)"},{"location":"Physics/6%20Statistics/zListOfCodes/#2050-poland-population-by-region-forecast","text":"ximport geopandas as gpd import numpy as np import matplotlib.pyplot as plt # Setting file path file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Reading specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names and verification poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Print to verify names from GeoDataFrame print(\"Regions from GeoDataFrame:\") print(poland_gdf['name'].unique()) # Reproject to a suitable CRS for Poland (EPSG:2180) poland_gdf = poland_gdf.to_crs(epsg=2180) # Define current population data dictionary current_population_2022 = { 'Lower Silesian': 2904457, 'Kuyavian-Pomeranian': 2083563, 'Lublin': 2119854, 'Lubusz': 1005630, '\u0141\u00f3d\u017a': 2436348, 'Lesser Poland': 3360428, 'Masovian': 5421823, 'Opole': 982249, 'Subcarpathian': 2128203, 'Podlachian': 1188866, 'Pomeranian': 2329218, 'Silesian': 4455701, '\u015awi\u0119tokrzyskie': 1216949, 'Warmian-Masurian': 1423965, 'Greater Poland': 3475329, 'West Pomeranian': 1687128 } # Define mapping for names name_map = { 'Dolno\u015bl\u0105skie': 'Lower Silesian', 'Kujawsko-Pomorskie': 'Kuyavian-Pomeranian', 'Lubelskie': 'Lublin', 'Lubuskie': 'Lubusz', '\u0141\u00f3dzkie': '\u0141\u00f3d\u017a', 'Ma\u0142opolskie': 'Lesser Poland', 'Mazowieckie': 'Masovian', 'Opolskie': 'Opole', 'Podkarpackie': 'Subcarpathian', 'Podlaskie': 'Podlachian', 'Pomorskie': 'Pomeranian', '\u015al\u0105skie': 'Silesian', '\u015awi\u0119tokrzyskie': '\u015awi\u0119tokrzyskie', 'Warmi\u0144sko-Mazurskie': 'Warmian-Masurian', 'Wielkopolskie': 'Greater Poland', 'Zachodniopomorskie': 'West Pomeranian' } # Simulation setup years = 2050 - 2022 iterations = 1000 growth_rate_mean = 0.005 growth_rate_std = 0.004 # Monte Carlo simulation projection_results = {region: [] for region in current_population_2022.keys()} for region, initial_population in current_population_2022.items(): for _ in range(iterations): population = initial_population for year in range(years): growth_rate = np.random.normal(growth_rate_mean, growth_rate_std) growth_rate = 1 if growth_rate == 0 else growth_rate population += population * growth_rate projection_results[region].append(population) # Function to map population using updated methodology def map_population(region_name): simulation_name = region_name if simulation_name is not None: return np.mean(projection_results[simulation_name]) else: return np.nan # Population projection poland_gdf['projected_population_2050'] = poland_gdf['name'].apply(map_population) # Print regions with NaN values print(\"Regions with NaN values after mapping:\") print(poland_gdf[poland_gdf['projected_population_2050'].isna()]['name']) # Plotting the results fig, ax = plt.subplots(1, 1, figsize=(12, 10)) poland_gdf.boundary.plot(ax=ax, linewidth=1) poland_gdf.plot(ax=ax, column='projected_population_2050', cmap='YlOrRd', legend=True) ax.set_title(\"Projected Population in 2050 in Poland by Region (Monte Carlo)\") ax.axis('off') # Add region names for x, y, label in zip(poland_gdf.geometry.centroid.x, poland_gdf.geometry.centroid.y, poland_gdf['name']): ax.text(x, y, label, fontsize=8, ha='center', va='center', color='black', alpha=0.6) plt.show()","title":"2050 Poland Population by Region (Forecast)"},{"location":"Physics/6%20Statistics/zListOfCodes/#2026-masovian-region-population-by-age-group-forecast","text":"import geopandas as gpd import numpy as np import matplotlib.pyplot as plt from shapely.geometry import Polygon # Set file path for the shapefile file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Read specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Filter GeoDataFrame to retain only the Masovian region masovian_gdf = poland_gdf[poland_gdf['name'] == 'Masovian'] # Reproject to a suitable CRS for Poland (EPSG:2180) masovian_gdf = masovian_gdf.to_crs(epsg=2180) # Current population for Masovian region current_population_masovian = 5421823 # Hypothetical age distribution percentages for the Masovian population age_distribution_percentages = { '1-12': 0.15, # 15% '13-18': 0.10, # 10% '19-35': 0.30, # 30% '36-50': 0.25, # 25% '>50': 0.20 # 20% } # Calculate initial population by age group initial_age_group_populations = { group: current_population_masovian * percentage for group, percentage in age_distribution_percentages.items() } # Simulation setup for Masovian region years = 2026 - 2022 iterations = 100 growth_rate_mean = 0.005 growth_rate_std = 0.004 # Monte Carlo simulation for each age group projection_results_by_age_group = {group: [] for group in initial_age_group_populations} for group, initial_population in initial_age_group_populations.items(): for _ in range(iterations): population = initial_population for year in range(years): growth_rate = np.random.normal(growth_rate_mean, growth_rate_std) population += population * growth_rate projection_results_by_age_group[group].append(population) # Calculate the mean of the simulated values for 2026 population for each age group mean_projected_population_by_age_group = { group: np.mean(populations) for group, populations in projection_results_by_age_group.items() } # Calculate the distribution of areas based on the simulated projected populations total_simulated_population = sum(mean_projected_population_by_age_group.values()) age_areas = {group: total_simulated_population * age_distribution_percentages[group] for group in mean_projected_population_by_age_group} # Generate sub-regions within Masovian based on these simulated projections total_area = masovian_gdf.geometry.area.iloc[0] original_geom = masovian_gdf.geometry.iloc[0] minx, miny, maxx, maxy = original_geom.bounds # Divide the region into vertical strips representing areas for different age groups current_minx = minx age_geometries = [] for age, volume in age_areas.items(): age_width = (volume / total_simulated_population) * (maxx - minx) geom_slice = original_geom.intersection(Polygon([(current_minx, miny), (current_minx + age_width, miny), (current_minx + age_width, maxy), (current_minx, maxy)])) age_geometries.append((age, geom_slice)) current_minx += age_width # Create a new GeoDataFrame for these simulated areas with projected populations age_gdf = gpd.GeoDataFrame({ 'age_group': [age for age, geom in age_geometries], 'geometry': [geom for age, geom in age_geometries], 'population_millions': [mean_projected_population_by_age_group[age] / 1e6 for age, geom in age_geometries], 'percentage': [age_distribution_percentages[age] * 100 for age, geom in age_geometries] }, crs=masovian_gdf.crs) # Plot the Masovian region with age group areas based on Monte Carlo projections fig, ax = plt.subplots(1, 1, figsize=(10, 8)) age_gdf.boundary.plot(ax=ax, color='black', linewidth=0.8) age_gdf.plot(ax=ax, column='age_group', cmap='Accent', legend=True, edgecolor='black', alpha=0.75) ax.set_title(\"Projected Age Group Areas in Masovian Region (Monte Carlo Simulation)\") ax.axis('off') # Annotate the areas with age group names, percentages, and population in millions for x, y, label, perc, pop in zip(age_gdf.geometry.centroid.x, age_gdf.geometry.centroid.y, age_gdf['age_group'], age_gdf['percentage'], age_gdf['population_millions']): ax.text(x, y, f\"{label}\\n{perc:.1f}%\\n{pop:.2f}M\", fontsize=10, ha='center', va='center', color='black', alpha=0.7) plt.show()","title":"2026 Masovian Region Population by Age group (Forecast)"},{"location":"Physics/6%20Statistics/zListOfCodes/#masovian-region-population-ages-13-18","text":"import geopandas as gpd import numpy as np import matplotlib.pyplot as plt from shapely.geometry import Point # Set file path for the shapefile file_path = \"https://mg-2025p03.github.io/physics/_pics/pl_shp.zip\" # Read specific layer poland_gdf = gpd.read_file(file_path, layer='pl') # Correct encoding of region names poland_gdf['name'] = poland_gdf['name'].apply(lambda x: x.encode('latin1').decode('utf-8')) # Filter GeoDataFrame to retain only the Masovian region masovian_gdf = poland_gdf[poland_gdf['name'] == 'Masovian'] # Reproject to a suitable CRS for Poland (EPSG:2180) masovian_gdf = masovian_gdf.to_crs(epsg=2180) # Define the population distribution for each specific age between 13 and 18 # Assuming equal distribution for simplification; these should be adjusted with real data if available age_distribution_percentages = { 13: 0.0167 * 4, # ~1.67% 14: 0.0167 / 4, 15: 0.0167 * 3, 16: 0.0167 / 3, 17: 0.0167 * 2, 18: 0.0167 / 2 } # Total population for ages 13-18 current_population_masovian = 5421823 population_ages_13_to_18 = current_population_masovian * sum(age_distribution_percentages.values()) # Adjust to total percentage if needed # Simulate data points for each individual age in the Masovian region ages = list(age_distribution_percentages.keys()) points_by_age = {age: [] for age in ages} num_simulations = 1000 # Total number of points to simulate across these ages minx, miny, maxx, maxy = masovian_gdf.total_bounds # Generate random points within the region for each age for age in ages: num_points = int(num_simulations * age_distribution_percentages[age]) # Proportional split # Print regions with NaN values print(\"Age Population Probability\", age, \":\", ((age_distribution_percentages[age] * current_population_masovian) / population_ages_13_to_18) * 100) for _ in range(num_points): while True: x = np.random.uniform(minx, maxx) y = np.random.uniform(miny, maxy) point = Point(x, y) if point.within(masovian_gdf.geometry.iloc[0]): points_by_age[age].append(point) break # Plot points within the Masovian region, differentiating by age fig, ax = plt.subplots(1, 1, figsize=(12, 10)) masovian_gdf.boundary.plot(ax=ax, color='black', linewidth=0.8) # Colors and labels for plotting different ages colors = ['red', 'green', 'blue', 'purple', 'cyan', 'orange'] for age, color in zip(ages, colors): # Create a GeoDataFrame for these points points_gdf = gpd.GeoDataFrame(geometry=points_by_age[age], crs=masovian_gdf.crs) points_gdf.plot(ax=ax, color=color, marker='o', markersize=5, alpha=0.7, label=f'Age {age}') ax.set_title(\" Simulated Distribution of Ages 13-18 in Masovian Region\") ax.axis('off') ax.legend(loc='upper right') plt.show()","title":"Masovian Region Population Ages 13-18"},{"location":"Physics/7%20Measurements/Problem_1/","text":"Problem definition This experiment provides a systematic approach to measuring the acceleration due to gravity $ g $ using a simple pendulum. Here is the detailed explanation of each step, along with how you can analyze uncertainties and other considerations: Procedure Details Materials String: A length of 1 to 1.5 meters. Small weight: Such as a bag of coins, a small bag of sugar, or a keychain. Stopwatch: Or a smartphone timer. Ruler or Measuring Tape: For measuring the length of the pendulum. Setup Pendulum Assembly: Attach the weight to the string and secure the other end to a stable support, allowing it to swing freely. Measurement of Length \\(L\\) : Use a ruler or tape to measure the pendulum length from the fixed point to the weight\u2019s center. Record the resolution of your measuring tool, e.g., \u00b10.1 cm for a tape measure, translating to an uncertainty of half the resolution \\(\u00b10.05 cm\\) . Data Collection Displacement and Release: Displace the pendulum by less than 15\u00b0 to minimize non-linear effects and release it. Timing Oscillations: Use the stopwatch to measure the time for 10 complete oscillations. Repeat this measurement 10 times to account for variability. Record all measurements. Calculate the Mean Time \\(\\bar{T}_{10}\\) : Find the average time for 10 oscillations. Standard Deviation \\(\\sigma\\) : Calculate to understand variability in the timing. Uncertainty in Mean Time \\(\\sigma_{\\bar{T}}\\) : Determined using \\(\\frac{\\sigma}{\\sqrt{N}}\\) where \\(( N = 10 )\\) . Calculations 1. Calculate the Period $ T $ \\[T = \\frac{\\bar{T}_{10}}{10}\\] The period of one oscillation. Determine Gravitational Acceleration $ g $ \\[g = \\frac{4\\pi^2L}{T^2}\\] Propagate Uncertainties Use error propagation methods to calculate the uncertainty in \\(g\\) based on uncertainties in \\(L\\) and \\(T\\) . Analysis 1. Compare with Standard Value Standard gravitational acceleration is approximately \\(9.81 , \\text{m/s}^2\\) . Compare your calculated \\(g\\) with this value. Discuss: Resolution Impact: How the precision of length and time measurements affect \\(g\\) . Timing Variability: Examine the standard deviation of time measurements and its effect on results. Assumptions and Limitations: Consider factors such as air resistance, assumption of small angles (linear approximation), and potential friction at the pivot.","title":"Problem definition"},{"location":"Physics/7%20Measurements/Problem_1/#problem-definition","text":"This experiment provides a systematic approach to measuring the acceleration due to gravity $ g $ using a simple pendulum. Here is the detailed explanation of each step, along with how you can analyze uncertainties and other considerations: Procedure Details Materials String: A length of 1 to 1.5 meters. Small weight: Such as a bag of coins, a small bag of sugar, or a keychain. Stopwatch: Or a smartphone timer. Ruler or Measuring Tape: For measuring the length of the pendulum. Setup Pendulum Assembly: Attach the weight to the string and secure the other end to a stable support, allowing it to swing freely. Measurement of Length \\(L\\) : Use a ruler or tape to measure the pendulum length from the fixed point to the weight\u2019s center. Record the resolution of your measuring tool, e.g., \u00b10.1 cm for a tape measure, translating to an uncertainty of half the resolution \\(\u00b10.05 cm\\) . Data Collection Displacement and Release: Displace the pendulum by less than 15\u00b0 to minimize non-linear effects and release it. Timing Oscillations: Use the stopwatch to measure the time for 10 complete oscillations. Repeat this measurement 10 times to account for variability. Record all measurements. Calculate the Mean Time \\(\\bar{T}_{10}\\) : Find the average time for 10 oscillations. Standard Deviation \\(\\sigma\\) : Calculate to understand variability in the timing. Uncertainty in Mean Time \\(\\sigma_{\\bar{T}}\\) : Determined using \\(\\frac{\\sigma}{\\sqrt{N}}\\) where \\(( N = 10 )\\) . Calculations 1. Calculate the Period $ T $ \\[T = \\frac{\\bar{T}_{10}}{10}\\] The period of one oscillation. Determine Gravitational Acceleration $ g $ \\[g = \\frac{4\\pi^2L}{T^2}\\] Propagate Uncertainties Use error propagation methods to calculate the uncertainty in \\(g\\) based on uncertainties in \\(L\\) and \\(T\\) . Analysis 1. Compare with Standard Value Standard gravitational acceleration is approximately \\(9.81 , \\text{m/s}^2\\) . Compare your calculated \\(g\\) with this value. Discuss: Resolution Impact: How the precision of length and time measurements affect \\(g\\) . Timing Variability: Examine the standard deviation of time measurements and its effect on results. Assumptions and Limitations: Consider factors such as air resistance, assumption of small angles (linear approximation), and potential friction at the pivot.","title":"Problem definition"}]}